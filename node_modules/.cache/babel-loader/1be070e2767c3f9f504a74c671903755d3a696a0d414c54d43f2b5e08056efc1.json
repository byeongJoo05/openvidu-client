{"ast":null,"code":"\"use strict\";\n\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Publisher = void 0;\nvar Session_1 = require(\"./Session\");\nvar Stream_1 = require(\"./Stream\");\nvar StreamManager_1 = require(\"./StreamManager\");\nvar StreamEvent_1 = require(\"../OpenViduInternal/Events/StreamEvent\");\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\n/**\n * @hidden\n */\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\nvar platform;\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with {@link OpenVidu.initPublisher} method.\n *\n * See available event listeners at {@link PublisherEventMap}.\n */\nvar Publisher = /** @class */function (_super) {\n  __extends(Publisher, _super);\n  /**\n   * @hidden\n   */\n  function Publisher(targEl, properties, openvidu) {\n    var _this = _super.call(this, new Stream_1.Stream(!!openvidu.session ? openvidu.session : new Session_1.Session(openvidu), {\n      publisherProperties: properties,\n      mediaConstraints: {}\n    }), targEl) || this;\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n    _this.accessAllowed = false;\n    /**\n     * Whether you have called {@link Publisher.subscribeToRemote} with value `true` or `false` (*false* by default)\n     */\n    _this.isSubscribedToRemote = false;\n    _this.accessDenied = false;\n    platform = Platform_1.PlatformUtils.getInstance();\n    _this.properties = properties;\n    _this.openvidu = openvidu;\n    _this.stream.ee.on('local-stream-destroyed', function (reason) {\n      _this.stream.isLocalStreamPublished = false;\n      var streamEvent = new StreamEvent_1.StreamEvent(true, _this, 'streamDestroyed', _this.stream, reason);\n      _this.emitEvent('streamDestroyed', [streamEvent]);\n      streamEvent.callDefaultBehavior();\n    });\n    return _this;\n  }\n  /**\n   * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The {@link Publisher} object of the local participant will also dispatch the exact same event\n   *\n   * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n   * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See {@link StreamPropertyChangedEvent} to learn more.\n   *\n   * @param enabled `true` to publish the audio stream, `false` to unpublish it\n   */\n  Publisher.prototype.publishAudio = function (enabled) {\n    var _this = this;\n    if (this.stream.audioActive !== enabled) {\n      var affectedMediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n      affectedMediaStream.getAudioTracks().forEach(function (track) {\n        track.enabled = enabled;\n      });\n      if (!!this.session && !!this.stream.streamId) {\n        this.session.openvidu.sendRequest('streamPropertyChanged', {\n          streamId: this.stream.streamId,\n          property: 'audioActive',\n          newValue: enabled,\n          reason: 'publishAudio'\n        }, function (error, response) {\n          if (error) {\n            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n          } else {\n            _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n            _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'audioActive', enabled, !enabled, 'publishAudio')]);\n            _this.session.sendVideoData(_this.stream.streamManager);\n          }\n        });\n      }\n      this.stream.audioActive = enabled;\n      logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n    }\n  };\n  /**\n   * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n   *\n   * #### Events dispatched\n   *\n   * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n   *\n   * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The {@link Publisher} object of the local participant will also dispatch the exact same event\n   *\n   * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n   * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n   *\n   * See {@link StreamPropertyChangedEvent} to learn more.\n   *\n   * @param enabled `true` to publish the video stream, `false` to unpublish it\n   * @param resource\n   * - If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n   * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n   * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.</li>\n   * - If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n   * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n   * will be used instead.\n   */\n  Publisher.prototype.publishVideo = function (enabled, resource) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var affectedMediaStream_1, mustRestartMediaStream_1, oldVideoTrack, replaceVideoTrack, mediaStream, error_1;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.stream.videoActive !== enabled)) return [3 /*break*/, 9];\n              affectedMediaStream_1 = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n              mustRestartMediaStream_1 = false;\n              affectedMediaStream_1.getVideoTracks().forEach(function (track) {\n                track.enabled = enabled;\n                if (!enabled && resource === true) {\n                  track.stop();\n                } else if (enabled && track.readyState === 'ended') {\n                  // Resource was freed\n                  mustRestartMediaStream_1 = true;\n                }\n              });\n              if (!(!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:'))) return [3 /*break*/, 2];\n              this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n              return [4 /*yield*/, this.stream.removeFilterAux(true)];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              if (!mustRestartMediaStream_1) return [3 /*break*/, 8];\n              oldVideoTrack = affectedMediaStream_1.getVideoTracks()[0];\n              affectedMediaStream_1.removeTrack(oldVideoTrack);\n              replaceVideoTrack = function replaceVideoTrack(tr) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var _this = this;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        affectedMediaStream_1.addTrack(tr);\n                        if (!this.stream.isLocalStreamPublished) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.replaceTrackInRtcRtpSender(tr)];\n                      case 1:\n                        _a.sent();\n                        _a.label = 2;\n                      case 2:\n                        if (!!this.stream.lastVBFilter) {\n                          setTimeout(function () {\n                            return __awaiter(_this, void 0, void 0, function () {\n                              var options, lastExecMethod;\n                              return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                  case 0:\n                                    options = this.stream.lastVBFilter.options;\n                                    lastExecMethod = this.stream.lastVBFilter.lastExecMethod;\n                                    if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                      options = Object.assign({}, options, lastExecMethod.params);\n                                    }\n                                    return [4 /*yield*/, this.stream.applyFilter(this.stream.lastVBFilter.type, options)];\n                                  case 1:\n                                    _a.sent();\n                                    delete this.stream.lastVBFilter;\n                                    return [2 /*return*/];\n                                }\n                              });\n                            });\n                          }, 1);\n                        }\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              if (!(!!resource && resource instanceof MediaStreamTrack)) return [3 /*break*/, 4];\n              return [4 /*yield*/, replaceVideoTrack(resource)];\n            case 3:\n              _a.sent();\n              return [3 /*break*/, 8];\n            case 4:\n              _a.trys.push([4, 7,, 8]);\n              return [4 /*yield*/, navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: this.stream.lastVideoTrackConstraints\n              })];\n            case 5:\n              mediaStream = _a.sent();\n              return [4 /*yield*/, replaceVideoTrack(mediaStream.getVideoTracks()[0])];\n            case 6:\n              _a.sent();\n              return [3 /*break*/, 8];\n            case 7:\n              error_1 = _a.sent();\n              return [2 /*return*/, reject(error_1)];\n            case 8:\n              if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest('streamPropertyChanged', {\n                  streamId: this.stream.streamId,\n                  property: 'videoActive',\n                  newValue: enabled,\n                  reason: 'publishVideo'\n                }, function (error, response) {\n                  if (error) {\n                    logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                  } else {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n                    _this.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this, _this.stream, 'videoActive', enabled, !enabled, 'publishVideo')]);\n                    _this.session.sendVideoData(_this.stream.streamManager);\n                  }\n                });\n              }\n              this.stream.videoActive = enabled;\n              logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n              return [2 /*return*/, resolve()];\n            case 9:\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Call this method before {@link Session.publish} if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n   */\n  Publisher.prototype.subscribeToRemote = function (value) {\n    value = value !== undefined ? value : true;\n    this.isSubscribedToRemote = value;\n    this.stream.subscribeToMyRemote(value);\n  };\n  /**\n   * See {@link EventDispatcher.on}\n   */\n  Publisher.prototype.on = function (type, handler) {\n    var _this = this;\n    _super.prototype.on.call(this, type, handler);\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.on('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n    return this;\n  };\n  /**\n   * See {@link EventDispatcher.once}\n   */\n  Publisher.prototype.once = function (type, handler) {\n    var _this = this;\n    _super.prototype.once.call(this, type, handler);\n    if (type === 'streamCreated') {\n      if (!!this.stream && this.stream.isLocalStreamPublished) {\n        this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n      } else {\n        this.stream.ee.once('stream-created-by-publisher', function () {\n          _this.emitEvent('streamCreated', [new StreamEvent_1.StreamEvent(false, _this, 'streamCreated', _this.stream, '')]);\n        });\n      }\n    }\n    if (type === 'accessAllowed') {\n      if (this.accessAllowed) {\n        this.emitEvent('accessAllowed', []);\n      }\n    }\n    if (type === 'accessDenied') {\n      if (this.accessDenied) {\n        this.emitEvent('accessDenied', []);\n      }\n    }\n    return this;\n  };\n  /**\n   * See {@link EventDispatcher.off}\n   */\n  Publisher.prototype.off = function (type, handler) {\n    _super.prototype.off.call(this, type, handler);\n    return this;\n  };\n  /**\n   * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n   * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n   * and publishing the new one).\n   *\n   * You can get this new MediaStreamTrack by using the native Web API or simply with {@link OpenVidu.getUserMedia} method.\n   *\n   * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n   * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n   * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n   *\n   * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n   * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n   */\n  Publisher.prototype.replaceTrack = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.replaceTrackAux(track, true)];\n      });\n    });\n  };\n  /* Hidden methods */\n  /**\n   * @hidden\n   */\n  Publisher.prototype.initialize = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var constraints, constraintsAux, timeForDialogEvent, startTime, errorCallback, successCallback, getMediaSuccess, getMediaError, myConstraints, outboundStreamOptions, definedAudioConstraint, mediaStream, mediaStream, error_2, error_3;\n        var _this = this;\n        var _a, _b;\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              constraints = {};\n              constraintsAux = {};\n              timeForDialogEvent = 2000;\n              errorCallback = function errorCallback(openViduError) {\n                _this.accessDenied = true;\n                _this.accessAllowed = false;\n                logger.error(\"Publisher initialization failed. \".concat(openViduError.name, \": \").concat(openViduError.message));\n                return reject(openViduError);\n              };\n              successCallback = function successCallback(mediaStream) {\n                var _a, _b;\n                _this.accessAllowed = true;\n                _this.accessDenied = false;\n                if (typeof MediaStreamTrack !== 'undefined' && _this.properties.audioSource instanceof MediaStreamTrack) {\n                  mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n                  mediaStream.addTrack(_this.properties.audioSource);\n                }\n                if (typeof MediaStreamTrack !== 'undefined' && _this.properties.videoSource instanceof MediaStreamTrack) {\n                  mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n                  mediaStream.addTrack(_this.properties.videoSource);\n                }\n                // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n                if (!!mediaStream.getAudioTracks()[0]) {\n                  var enabled = _this.stream.audioActive !== undefined && _this.stream.audioActive !== null ? _this.stream.audioActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n                  mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!mediaStream.getVideoTracks()[0]) {\n                  var enabled = _this.stream.videoActive !== undefined && _this.stream.videoActive !== null ? _this.stream.videoActive : !!_this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n                  mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n                // Set Content Hint on all MediaStreamTracks\n                for (var _i = 0, _c = mediaStream.getAudioTracks(); _i < _c.length; _i++) {\n                  var track = _c[_i];\n                  if (!((_a = track.contentHint) === null || _a === void 0 ? void 0 : _a.length)) {\n                    // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n                    // https://w3c.github.io/mst-content-hint/#audio-content-hints\n                    track.contentHint = '';\n                    logger.info(\"Audio track Content Hint set: '\".concat(track.contentHint, \"'\"));\n                  }\n                }\n                for (var _d = 0, _e = mediaStream.getVideoTracks(); _d < _e.length; _d++) {\n                  var track = _e[_d];\n                  if (!((_b = track.contentHint) === null || _b === void 0 ? void 0 : _b.length)) {\n                    // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n                    // https://w3c.github.io/mst-content-hint/#video-content-hints\n                    switch (_this.stream.typeOfVideo) {\n                      case TypeOfVideo_1.TypeOfVideo.SCREEN:\n                        track.contentHint = 'detail';\n                        break;\n                      case TypeOfVideo_1.TypeOfVideo.CUSTOM:\n                        logger.warn('CUSTOM type video track was provided without Content Hint!');\n                        track.contentHint = 'motion';\n                        break;\n                      case TypeOfVideo_1.TypeOfVideo.CAMERA:\n                      case TypeOfVideo_1.TypeOfVideo.IPCAM:\n                      default:\n                        track.contentHint = 'motion';\n                        break;\n                    }\n                    logger.info(\"Video track Content Hint set: '\".concat(track.contentHint, \"'\"));\n                  }\n                }\n                _this.initializeVideoReference(mediaStream);\n                if (!_this.stream.displayMyRemote()) {\n                  // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n                  // avoid early 'streamPlaying' event\n                  _this.stream.updateMediaStreamInVideos();\n                }\n                delete _this.firstVideoElement;\n                if (_this.stream.isSendVideo()) {\n                  // Has video track\n                  _this.getVideoDimensions().then(function (dimensions) {\n                    _this.stream.videoDimensions = {\n                      width: dimensions.width,\n                      height: dimensions.height\n                    };\n                    if (_this.stream.isSendScreen()) {\n                      // Set interval to listen for screen resize events\n                      _this.screenShareResizeInterval = setInterval(function () {\n                        var settings = mediaStream.getVideoTracks()[0].getSettings();\n                        var newWidth = settings.width;\n                        var newHeight = settings.height;\n                        var widthChanged = newWidth != null && newWidth !== _this.stream.videoDimensions.width;\n                        var heightChanged = newHeight != null && newHeight !== _this.stream.videoDimensions.height;\n                        if (_this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                          _this.openvidu.sendVideoDimensionsChangedEvent(_this, 'screenResized', _this.stream.videoDimensions.width, _this.stream.videoDimensions.height, newWidth || 0, newHeight || 0);\n                        }\n                      }, 650);\n                    }\n                    _this.stream.isLocalStreamReadyToPublish = true;\n                    _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                  });\n                } else {\n                  // Only audio track (no videoDimensions)\n                  _this.stream.isLocalStreamReadyToPublish = true;\n                  _this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                }\n                return resolve();\n              };\n              getMediaSuccess = function getMediaSuccess(mediaStream, definedAudioConstraint) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var audioOnlyStream, error_4;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        if (!(this.stream.isSendScreen() && this.stream.isSendAudio())) return [3 /*break*/, 5];\n                        // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n                        constraintsAux.audio = definedAudioConstraint;\n                        constraintsAux.video = false;\n                        startTime = Date.now();\n                        this.setPermissionDialogTimer(timeForDialogEvent);\n                        _a.label = 1;\n                      case 1:\n                        _a.trys.push([1, 3,, 4]);\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraintsAux)];\n                      case 2:\n                        audioOnlyStream = _a.sent();\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n                        successCallback(mediaStream);\n                        return [3 /*break*/, 4];\n                      case 3:\n                        error_4 = _a.sent();\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.getAudioTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        mediaStream.getVideoTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        errorCallback(this.openvidu.generateAudioDeviceError(error_4, constraints));\n                        return [2 /*return*/];\n                      case 4:\n                        return [3 /*break*/, 6];\n                      case 5:\n                        successCallback(mediaStream);\n                        _a.label = 6;\n                      case 6:\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              getMediaError = function getMediaError(error) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var errorName, errorMessage, _a, mediaStream, error_5, mediaStream, error_6;\n                  return __generator(this, function (_b) {\n                    switch (_b.label) {\n                      case 0:\n                        logger.error(\"getMediaError: \".concat(error.toString()));\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        if (error.name === 'Error') {\n                          // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n                          error.name = error.constructor.name;\n                        }\n                        _a = error.name.toLowerCase();\n                        switch (_a) {\n                          case 'notfounderror':\n                            return [3 /*break*/, 1];\n                          case 'notallowederror':\n                            return [3 /*break*/, 5];\n                          case 'overconstrainederror':\n                            return [3 /*break*/, 6];\n                          case 'aborterror':\n                            return [3 /*break*/, 10];\n                          case 'notreadableerror':\n                            return [3 /*break*/, 10];\n                        }\n                        return [3 /*break*/, 11];\n                      case 1:\n                        _b.trys.push([1, 3,, 4]);\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({\n                          audio: false,\n                          video: constraints.video\n                        })];\n                      case 2:\n                        mediaStream = _b.sent();\n                        mediaStream.getVideoTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 4];\n                      case 3:\n                        error_5 = _b.sent();\n                        errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                        errorMessage = error_5.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 4];\n                      case 4:\n                        return [3 /*break*/, 12];\n                      case 5:\n                        errorName = this.stream.isSendScreen() ? OpenViduError_1.OpenViduErrorName.SCREEN_CAPTURE_DENIED : OpenViduError_1.OpenViduErrorName.DEVICE_ACCESS_DENIED;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 12];\n                      case 6:\n                        _b.trys.push([6, 8,, 9]);\n                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({\n                          audio: false,\n                          video: constraints.video\n                        })];\n                      case 7:\n                        mediaStream = _b.sent();\n                        mediaStream.getVideoTracks().forEach(function (track) {\n                          track.stop();\n                        });\n                        if (error.constraint.toLowerCase() === 'deviceid') {\n                          errorName = OpenViduError_1.OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                          errorMessage = \"Audio input device with deviceId '\" + constraints.audio.deviceId.exact + \"' not found\";\n                        } else {\n                          errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                          errorMessage = \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                        }\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 9];\n                      case 8:\n                        error_6 = _b.sent();\n                        if (error_6.constraint.toLowerCase() === 'deviceid') {\n                          errorName = OpenViduError_1.OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                          errorMessage = \"Video input device with deviceId '\" + constraints.video.deviceId.exact + \"' not found\";\n                        } else {\n                          errorName = OpenViduError_1.OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                          errorMessage = \"Video input device doesn't support the value passed for constraint '\" + error_6.constraint + \"'\";\n                        }\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 9];\n                      case 9:\n                        return [3 /*break*/, 12];\n                      case 10:\n                        errorName = OpenViduError_1.OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 12];\n                      case 11:\n                        errorName = OpenViduError_1.OpenViduErrorName.GENERIC_ERROR;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError_1.OpenViduError(errorName, errorMessage));\n                        return [3 /*break*/, 12];\n                      case 12:\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              _c.label = 1;\n            case 1:\n              _c.trys.push([1, 14,, 15]);\n              return [4 /*yield*/, this.openvidu.generateMediaConstraints(this.properties)];\n            case 2:\n              myConstraints = _c.sent();\n              if (!(!!myConstraints.videoTrack && !!myConstraints.audioTrack || !!myConstraints.audioTrack && ((_a = myConstraints.constraints) === null || _a === void 0 ? void 0 : _a.video) === false || !!myConstraints.videoTrack && ((_b = myConstraints.constraints) === null || _b === void 0 ? void 0 : _b.audio) === false)) return [3 /*break*/, 3];\n              // No need to call getUserMedia at all. MediaStreamTracks already provided\n              successCallback(this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), this.stream));\n              return [3 /*break*/, 13];\n            case 3:\n              constraints = myConstraints.constraints;\n              outboundStreamOptions = {\n                mediaConstraints: constraints,\n                publisherProperties: this.properties\n              };\n              this.stream.setOutboundStreamOptions(outboundStreamOptions);\n              definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n              constraintsAux.audio = this.stream.isSendScreen() ? false : definedAudioConstraint;\n              constraintsAux.video = constraints.video;\n              startTime = Date.now();\n              this.setPermissionDialogTimer(timeForDialogEvent);\n              _c.label = 4;\n            case 4:\n              _c.trys.push([4, 11,, 13]);\n              if (!(this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron())) return [3 /*break*/, 7];\n              return [4 /*yield*/, navigator.mediaDevices['getDisplayMedia']({\n                video: true\n              })];\n            case 5:\n              mediaStream = _c.sent();\n              this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n              return [4 /*yield*/, getMediaSuccess(mediaStream, definedAudioConstraint)];\n            case 6:\n              _c.sent();\n              return [3 /*break*/, 10];\n            case 7:\n              this.stream.lastVideoTrackConstraints = constraintsAux.video;\n              return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraintsAux)];\n            case 8:\n              mediaStream = _c.sent();\n              this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, this.stream);\n              return [4 /*yield*/, getMediaSuccess(mediaStream, definedAudioConstraint)];\n            case 9:\n              _c.sent();\n              _c.label = 10;\n            case 10:\n              return [3 /*break*/, 13];\n            case 11:\n              error_2 = _c.sent();\n              return [4 /*yield*/, getMediaError(error_2)];\n            case 12:\n              _c.sent();\n              return [3 /*break*/, 13];\n            case 13:\n              return [3 /*break*/, 15];\n            case 14:\n              error_3 = _c.sent();\n              errorCallback(error_3);\n              return [3 /*break*/, 15];\n            case 15:\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.replaceTrackAux = function (track, updateLastConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trackOriginalEnabledValue, error_7;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            trackOriginalEnabledValue = track.enabled;\n            if (track.kind === 'video') {\n              track.enabled = this.stream.videoActive;\n            } else if (track.kind === 'audio') {\n              track.enabled = this.stream.audioActive;\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n            if (!this.stream.isLocalStreamPublished) return [3 /*break*/, 3];\n            // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n            // If it has not been published yet, replacing it on the MediaStream object is enough\n            this.replaceTrackInMediaStream(track, updateLastConstraints);\n            return [4 /*yield*/, this.replaceTrackInRtcRtpSender(track)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            // Publisher not published. Simply replace the track on the local MediaStream\n            return [2 /*return*/, this.replaceTrackInMediaStream(track, updateLastConstraints)];\n          case 4:\n            return [3 /*break*/, 6];\n          case 5:\n            error_7 = _a.sent();\n            track.enabled = trackOriginalEnabledValue;\n            throw error_7;\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   *\n   * To obtain the videoDimensions we wait for the video reference to have enough metadata\n   * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n   * use the HTMLVideoElement properties videoWidth and videoHeight\n   */\n  Publisher.prototype.getVideoDimensions = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n      var requiresDomInsertion = platform.isIonicIos() || platform.isIOSWithSafari();\n      var loadedmetadataListener;\n      var resolveDimensions = function resolveDimensions() {\n        var width;\n        var height;\n        if (typeof _this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n          var settings = _this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n          width = settings.width || _this.videoReference.videoWidth;\n          height = settings.height || _this.videoReference.videoHeight;\n        } else {\n          logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n          width = _this.videoReference.videoWidth;\n          height = _this.videoReference.videoHeight;\n        }\n        if (loadedmetadataListener != null) {\n          _this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n        }\n        if (requiresDomInsertion) {\n          document.body.removeChild(_this.videoReference);\n        }\n        return resolve({\n          width: width,\n          height: height\n        });\n      };\n      if (_this.videoReference.readyState >= 1) {\n        // The video already has metadata available\n        // No need of loadedmetadata event\n        resolveDimensions();\n      } else {\n        // The video does not have metadata available yet\n        // Must listen to loadedmetadata event\n        loadedmetadataListener = function loadedmetadataListener() {\n          if (!_this.videoReference.videoWidth) {\n            var interval_1 = setInterval(function () {\n              if (!!_this.videoReference.videoWidth) {\n                clearInterval(interval_1);\n                resolveDimensions();\n              }\n            }, 40);\n          } else {\n            resolveDimensions();\n          }\n        };\n        _this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n        if (requiresDomInsertion) {\n          document.body.appendChild(_this.videoReference);\n        }\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.reestablishStreamPlayingEvent = function () {\n    if (this.ee.getListeners('streamPlaying').length > 0) {\n      this.addPlayEventToFirstVideo();\n    }\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.initializeVideoReference = function (mediaStream) {\n    this.videoReference = document.createElement('video');\n    this.videoReference.style.display = 'none';\n    this.videoReference.muted = true;\n    this.videoReference.autoplay = true;\n    this.videoReference.controls = false;\n    if (platform.isSafariBrowser() || platform.isIPhoneOrIPad() && (platform.isChromeMobileBrowser() || platform.isEdgeMobileBrowser() || platform.isOperaMobileBrowser() || platform.isFirefoxMobileBrowser())) {\n      this.videoReference.playsInline = true;\n    }\n    this.stream.setMediaStream(mediaStream);\n    if (!!this.firstVideoElement) {\n      this.createVideoElement(this.firstVideoElement.targetElement, this.properties.insertMode);\n    }\n    this.videoReference.srcObject = this.stream.getMediaStream();\n  };\n  /**\n   * @hidden\n   */\n  Publisher.prototype.replaceTrackInMediaStream = function (track, updateLastConstraints) {\n    var mediaStream = this.stream.displayMyRemote() ? this.stream.localMediaStreamWhenSubscribedToRemote : this.stream.getMediaStream();\n    var removedTrack;\n    if (track.kind === 'video') {\n      removedTrack = mediaStream.getVideoTracks()[0];\n      if (updateLastConstraints) {\n        this.stream.lastVideoTrackConstraints = track.getConstraints();\n      }\n    } else {\n      removedTrack = mediaStream.getAudioTracks()[0];\n    }\n    removedTrack.enabled = false;\n    removedTrack.stop();\n    mediaStream.removeTrack(removedTrack);\n    mediaStream.addTrack(track);\n    var trackInfo = {\n      oldLabel: (removedTrack === null || removedTrack === void 0 ? void 0 : removedTrack.label) || '',\n      newLabel: (track === null || track === void 0 ? void 0 : track.label) || ''\n    };\n    if (track.kind === 'video' && updateLastConstraints) {\n      this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n      this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'videoTrack');\n      if (this.stream.isLocalStreamPublished) {\n        this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n      }\n    } else if (track.kind === 'audio' && updateLastConstraints) {\n      this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'audioTrack');\n    }\n    if (track.kind === 'audio') {\n      this.stream.disableHarkSpeakingEvent(false);\n      this.stream.disableHarkStoppedSpeakingEvent(false);\n      this.stream.disableHarkVolumeChangeEvent(false);\n      this.stream.initHarkEvents();\n    }\n  };\n  /* Private methods */\n  Publisher.prototype.setPermissionDialogTimer = function (waitTime) {\n    var _this = this;\n    this.permissionDialogTimeout = setTimeout(function () {\n      _this.emitEvent('accessDialogOpened', []);\n    }, waitTime);\n  };\n  Publisher.prototype.clearPermissionDialogTimer = function (startTime, waitTime) {\n    clearTimeout(this.permissionDialogTimeout);\n    if (Date.now() - startTime > waitTime) {\n      // Permission dialog was shown and now is closed\n      this.emitEvent('accessDialogClosed', []);\n    }\n  };\n  Publisher.prototype.replaceTrackInRtcRtpSender = function (track) {\n    return __awaiter(this, void 0, void 0, function () {\n      var senders, sender;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            senders = this.stream.getRTCPeerConnection().getSenders();\n            if (track.kind === 'video') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'video';\n              });\n              if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n              }\n            } else if (track.kind === 'audio') {\n              sender = senders.find(function (s) {\n                return !!s.track && s.track.kind === 'audio';\n              });\n              if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n              }\n            } else {\n              throw new Error('Unknown track kind ' + track.kind);\n            }\n            return [4 /*yield*/, sender.replaceTrack(track)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return Publisher;\n}(StreamManager_1.StreamManager);\nexports.Publisher = Publisher;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","__extends","targEl","properties","openvidu","_super","Stream_1","session","Session_1","publisherProperties","mediaConstraints","_this","Platform_1","stream","ee","on","reason","isLocalStreamPublished","streamEvent","StreamEvent_1","emitEvent","callDefaultBehavior","Publisher","enabled","audioActive","affectedMediaStream","displayMyRemote","localMediaStreamWhenSubscribedToRemote","getMediaStream","getAudioTracks","forEach","track","streamId","sendRequest","property","newValue","error","response","StreamPropertyChangedEvent_1","sendVideoData","streamManager","info","resource","Promise","resolve","reject","videoActive","affectedMediaStream_1","mustRestartMediaStream_1","getVideoTracks","stop","readyState","filter","type","startsWith","lastVBFilter","removeFilterAux","_a","oldVideoTrack","removeTrack","replaceVideoTrack","tr","addTrack","replaceTrackInRtcRtpSender","setTimeout","options","lastExecMethod","method","Object","assign","params","applyFilter","MediaStreamTrack","navigator","mediaDevices","getUserMedia","audio","video","lastVideoTrackConstraints","mediaStream","error_1","value","undefined","isSubscribedToRemote","subscribeToMyRemote","handler","accessAllowed","accessDenied","once","off","replaceTrackAux","constraints","constraintsAux","timeForDialogEvent","errorCallback","openViduError","name","message","successCallback","audioSource","videoSource","outboundStreamOpts","publishAudio","publishVideo","_c","_i","contentHint","length","_e","_d","typeOfVideo","TypeOfVideo_1","SCREEN","CUSTOM","warn","CAMERA","IPCAM","initializeVideoReference","updateMediaStreamInVideos","firstVideoElement","isSendVideo","getVideoDimensions","then","dimensions","videoDimensions","width","height","isSendScreen","screenShareResizeInterval","setInterval","settings","getSettings","newWidth","newHeight","widthChanged","heightChanged","sendVideoDimensionsChangedEvent","isLocalStreamReadyToPublish","getMediaSuccess","definedAudioConstraint","clearPermissionDialogTimer","startTime","isSendAudio","Date","now","setPermissionDialogTimer","audioOnlyStream","generateAudioDeviceError","error_4","getMediaError","toString","constructor","toLowerCase","_b","errorName","OpenViduError_1","INPUT_AUDIO_DEVICE_NOT_FOUND","errorMessage","INPUT_VIDEO_DEVICE_NOT_FOUND","error_5","SCREEN_CAPTURE_DENIED","DEVICE_ACCESS_DENIED","constraint","deviceId","exact","PUBLISHER_PROPERTIES_ERROR","error_6","DEVICE_ALREADY_IN_USE","GENERIC_ERROR","generateMediaConstraints","myConstraints","videoTrack","audioTrack","addAlreadyProvidedTracks","MediaStream","outboundStreamOptions","setOutboundStreamOptions","isElectron","error_2","error_3","updateLastConstraints","trackOriginalEnabledValue","kind","replaceTrackInMediaStream","error_7","requiresDomInsertion","isIonicIos","isIOSWithSafari","loadedmetadataListener","resolveDimensions","videoReference","videoWidth","videoHeight","getDescription","removeEventListener","document","body","removeChild","interval_1","clearInterval","addEventListener","appendChild","getListeners","addPlayEventToFirstVideo","createElement","style","display","muted","autoplay","controls","isSafariBrowser","isIPhoneOrIPad","isChromeMobileBrowser","isEdgeMobileBrowser","isOperaMobileBrowser","isFirefoxMobileBrowser","playsInline","setMediaStream","createVideoElement","targetElement","insertMode","srcObject","removedTrack","getConstraints","trackInfo","oldLabel","label","newLabel","sendNewVideoDimensionsIfRequired","sendTrackChangedEvent","disableHarkSpeakingEvent","disableHarkStoppedSpeakingEvent","disableHarkVolumeChangeEvent","initHarkEvents","waitTime","permissionDialogTimeout","clearTimeout","senders","getRTCPeerConnection","getSenders","sender","find","s","Error","replaceTrack","StreamManager_1","exports"],"sources":["C:\\Users\\user\\Desktop\\openvidu-client\\node_modules\\openvidu-browser\\src\\OpenVidu\\Publisher.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { OpenVidu } from './OpenVidu';\nimport { Session } from './Session';\nimport { Stream } from './Stream';\nimport { StreamManager } from './StreamManager';\nimport { PublisherProperties } from '../OpenViduInternal/Interfaces/Public/PublisherProperties';\nimport { PublisherEventMap } from '../OpenViduInternal/Events/EventMap/PublisherEventMap';\nimport { StreamEvent } from '../OpenViduInternal/Events/StreamEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { VideoInsertMode } from '../OpenViduInternal/Enums/VideoInsertMode';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\nimport { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';\nimport { StreamEventReason } from '../OpenViduInternal/Events/Types/Types';\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Packs local media streams. Participants can publish it to a session. Initialized with {@link OpenVidu.initPublisher} method.\n *\n * See available event listeners at {@link PublisherEventMap}.\n */\nexport class Publisher extends StreamManager {\n    /**\n     * Whether the Publisher has been granted access to the requested input devices or not\n     */\n    accessAllowed = false;\n\n    /**\n     * Whether you have called {@link Publisher.subscribeToRemote} with value `true` or `false` (*false* by default)\n     */\n    isSubscribedToRemote = false;\n\n    /**\n     * The {@link Session} to which the Publisher belongs\n     */\n    session: Session; // Initialized by Session.publish(Publisher)\n\n    private accessDenied = false;\n    protected properties: PublisherProperties;\n    private permissionDialogTimeout: NodeJS.Timer;\n\n    /**\n     * @hidden\n     */\n    openvidu: OpenVidu;\n    /**\n     * @hidden\n     */\n    videoReference: HTMLVideoElement;\n    /**\n     * @hidden\n     */\n    screenShareResizeInterval: NodeJS.Timer;\n\n    /**\n     * @hidden\n     */\n    constructor(targEl: string | HTMLElement | undefined, properties: PublisherProperties, openvidu: OpenVidu) {\n        super(\n            new Stream(!!openvidu.session ? openvidu.session : new Session(openvidu), {\n                publisherProperties: properties,\n                mediaConstraints: {}\n            }),\n            targEl\n        );\n        platform = PlatformUtils.getInstance();\n        this.properties = properties;\n        this.openvidu = openvidu;\n\n        this.stream.ee.on('local-stream-destroyed', (reason: StreamEventReason) => {\n            this.stream.isLocalStreamPublished = false;\n            const streamEvent = new StreamEvent(true, this, 'streamDestroyed', this.stream, reason);\n            this.emitEvent('streamDestroyed', [streamEvent]);\n            streamEvent.callDefaultBehavior();\n        });\n    }\n\n    /**\n     * Publish or unpublish the audio stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n     *\n     * #### Events dispatched\n     *\n     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n     *\n     * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n     * The {@link Publisher} object of the local participant will also dispatch the exact same event\n     *\n     * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"audioActive\"` and `reason` set to `\"publishAudio\"`\n     * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n     *\n     * See {@link StreamPropertyChangedEvent} to learn more.\n     *\n     * @param enabled `true` to publish the audio stream, `false` to unpublish it\n     */\n    publishAudio(enabled: boolean): void {\n        if (this.stream.audioActive !== enabled) {\n            const affectedMediaStream: MediaStream = this.stream.displayMyRemote()\n                ? this.stream.localMediaStreamWhenSubscribedToRemote!\n                : this.stream.getMediaStream();\n            affectedMediaStream.getAudioTracks().forEach((track) => {\n                track.enabled = enabled;\n            });\n            if (!!this.session && !!this.stream.streamId) {\n                this.session.openvidu.sendRequest(\n                    'streamPropertyChanged',\n                    {\n                        streamId: this.stream.streamId,\n                        property: 'audioActive',\n                        newValue: enabled,\n                        reason: 'publishAudio'\n                    },\n                    (error, response) => {\n                        if (error) {\n                            logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                        } else {\n                            this.session.emitEvent('streamPropertyChanged', [\n                                new StreamPropertyChangedEvent(this.session, this.stream, 'audioActive', enabled, !enabled, 'publishAudio')\n                            ]);\n                            this.emitEvent('streamPropertyChanged', [\n                                new StreamPropertyChangedEvent(this, this.stream, 'audioActive', enabled, !enabled, 'publishAudio')\n                            ]);\n                            this.session.sendVideoData(this.stream.streamManager);\n                        }\n                    }\n                );\n            }\n            this.stream.audioActive = enabled;\n            logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its audio stream');\n        }\n    }\n\n    /**\n     * Publish or unpublish the video stream (if available). Calling this method twice in a row passing same `enabled` value will have no effect\n     *\n     * #### Events dispatched\n     *\n     * > _Only if `Session.publish(Publisher)` has been called for this Publisher_\n     *\n     * The {@link Session} object of the local participant will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n     * The {@link Publisher} object of the local participant will also dispatch the exact same event\n     *\n     * The {@link Session} object of every other participant connected to the session will dispatch a `streamPropertyChanged` event with `changedProperty` set to `\"videoActive\"` and `reason` set to `\"publishVideo\"`\n     * The respective {@link Subscriber} object of every other participant receiving this Publisher's stream will also dispatch the exact same event\n     *\n     * See {@link StreamPropertyChangedEvent} to learn more.\n     *\n     * @param enabled `true` to publish the video stream, `false` to unpublish it\n     * @param resource\n     * - If parameter **`enabled`** is `false`, this optional parameter is of type boolean. It can be set to `true` to forcibly free the hardware resource associated to the video track, or can be set to `false` to keep the access to the hardware resource.\n     * Not freeing the resource makes the operation much more efficient, but depending on the platform two side-effects can be introduced: the video device may not be accessible by other applications and the access light of\n     * webcams may remain on. This is platform-dependent: some browsers will not present the side-effects even when not freeing the resource.</li>\n     * - If parameter **`enabled`** is `true`, this optional parameter is of type [MediaStreamTrack](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack). It can be set to force the restoration of the video track with a custom track. This may be\n     * useful if the Publisher was unpublished freeing the hardware resource, and openvidu-browser is not able to successfully re-create the video track as it was before unpublishing. In this way previous track settings will be ignored and this MediaStreamTrack\n     * will be used instead.\n     */\n    publishVideo<T extends boolean>(enabled: T, resource?: T extends false ? boolean : MediaStreamTrack): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            if (this.stream.videoActive !== enabled) {\n                const affectedMediaStream: MediaStream = this.stream.displayMyRemote()\n                    ? this.stream.localMediaStreamWhenSubscribedToRemote!\n                    : this.stream.getMediaStream();\n                let mustRestartMediaStream = false;\n                affectedMediaStream.getVideoTracks().forEach((track) => {\n                    track.enabled = enabled;\n                    if (!enabled && resource === true) {\n                        track.stop();\n                    } else if (enabled && track.readyState === 'ended') {\n                        // Resource was freed\n                        mustRestartMediaStream = true;\n                    }\n                });\n\n                // There is a Virtual Background filter applied that must be removed in case the hardware must be freed\n                if (!enabled && resource === true && !!this.stream.filter && this.stream.filter.type.startsWith('VB:')) {\n                    this.stream.lastVBFilter = this.stream.filter; // Save the filter to be re-applied in case of unmute\n                    await this.stream.removeFilterAux(true);\n                }\n\n                if (mustRestartMediaStream) {\n                    const oldVideoTrack = affectedMediaStream.getVideoTracks()[0];\n                    affectedMediaStream.removeTrack(oldVideoTrack);\n\n                    const replaceVideoTrack = async (tr: MediaStreamTrack) => {\n                        affectedMediaStream.addTrack(tr);\n                        if (this.stream.isLocalStreamPublished) {\n                            await this.replaceTrackInRtcRtpSender(tr);\n                        }\n                        if (!!this.stream.lastVBFilter) {\n                            setTimeout(async () => {\n                                let options = this.stream.lastVBFilter!.options;\n                                const lastExecMethod = this.stream.lastVBFilter!.lastExecMethod;\n                                if (!!lastExecMethod && lastExecMethod.method === 'update') {\n                                    options = Object.assign({}, options, lastExecMethod.params);\n                                }\n                                await this.stream.applyFilter(this.stream.lastVBFilter!.type, options);\n                                delete this.stream.lastVBFilter;\n                            }, 1);\n                        }\n                    };\n\n                    if (!!resource && resource instanceof MediaStreamTrack) {\n                        await replaceVideoTrack(resource);\n                    } else {\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: this.stream.lastVideoTrackConstraints\n                            });\n                            await replaceVideoTrack(mediaStream.getVideoTracks()[0]);\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                }\n\n                if (!!this.session && !!this.stream.streamId) {\n                    this.session.openvidu.sendRequest(\n                        'streamPropertyChanged',\n                        {\n                            streamId: this.stream.streamId,\n                            property: 'videoActive',\n                            newValue: enabled,\n                            reason: 'publishVideo'\n                        },\n                        (error, response) => {\n                            if (error) {\n                                logger.error(\"Error sending 'streamPropertyChanged' event\", error);\n                            } else {\n                                this.session.emitEvent('streamPropertyChanged', [\n                                    new StreamPropertyChangedEvent(\n                                        this.session,\n                                        this.stream,\n                                        'videoActive',\n                                        enabled,\n                                        !enabled,\n                                        'publishVideo'\n                                    )\n                                ]);\n                                this.emitEvent('streamPropertyChanged', [\n                                    new StreamPropertyChangedEvent(this, this.stream, 'videoActive', enabled, !enabled, 'publishVideo')\n                                ]);\n                                this.session.sendVideoData(this.stream.streamManager);\n                            }\n                        }\n                    );\n                }\n                this.stream.videoActive = enabled;\n                logger.info(\"'Publisher' has \" + (enabled ? 'published' : 'unpublished') + ' its video stream');\n                return resolve();\n            }\n        });\n    }\n\n    /**\n     * Call this method before {@link Session.publish} if you prefer to subscribe to your Publisher's remote stream instead of using the local stream, as any other user would do.\n     */\n    subscribeToRemote(value?: boolean): void {\n        value = value !== undefined ? value : true;\n        this.isSubscribedToRemote = value;\n        this.stream.subscribeToMyRemote(value);\n    }\n\n    /**\n     * See {@link EventDispatcher.on}\n     */\n    on<K extends keyof PublisherEventMap>(type: K, handler: (event: PublisherEventMap[K]) => void): this {\n        super.on(<any>type, handler);\n\n        if (type === 'streamCreated') {\n            if (!!this.stream && this.stream.isLocalStreamPublished) {\n                this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n            } else {\n                this.stream.ee.on('stream-created-by-publisher', () => {\n                    this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n                });\n            }\n        }\n        if (type === 'accessAllowed') {\n            if (this.accessAllowed) {\n                this.emitEvent('accessAllowed', []);\n            }\n        }\n        if (type === 'accessDenied') {\n            if (this.accessDenied) {\n                this.emitEvent('accessDenied', []);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * See {@link EventDispatcher.once}\n     */\n    once<K extends keyof PublisherEventMap>(type: K, handler: (event: PublisherEventMap[K]) => void): this {\n        super.once(<any>type, handler);\n\n        if (type === 'streamCreated') {\n            if (!!this.stream && this.stream.isLocalStreamPublished) {\n                this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n            } else {\n                this.stream.ee.once('stream-created-by-publisher', () => {\n                    this.emitEvent('streamCreated', [new StreamEvent(false, this, 'streamCreated', this.stream, '')]);\n                });\n            }\n        }\n        if (type === 'accessAllowed') {\n            if (this.accessAllowed) {\n                this.emitEvent('accessAllowed', []);\n            }\n        }\n        if (type === 'accessDenied') {\n            if (this.accessDenied) {\n                this.emitEvent('accessDenied', []);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * See {@link EventDispatcher.off}\n     */\n    off<K extends keyof PublisherEventMap>(type: K, handler?: (event: PublisherEventMap[K]) => void): this {\n        super.off(<any>type, handler);\n        return this;\n    }\n\n    /**\n     * Replaces the current video or audio track with a different one. This allows you to replace an ongoing track with a different one\n     * without having to renegotiate the whole WebRTC connection (that is, initializing a new Publisher, unpublishing the previous one\n     * and publishing the new one).\n     *\n     * You can get this new MediaStreamTrack by using the native Web API or simply with {@link OpenVidu.getUserMedia} method.\n     *\n     * **WARNING: this method has been proven to work in the majority of cases, but there may be some combinations of published/replaced tracks that may be incompatible\n     * between them and break the connection in OpenVidu Server. A complete renegotiation may be the only solution in this case.\n     * Visit [RTCRtpSender.replaceTrack](https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender/replaceTrack) documentation for further details.**\n     *\n     * @param track The [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object to replace the current one.\n     * If it is an audio track, the current audio track will be the replaced one. If it is a video track, the current video track will be the replaced one.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the track was successfully replaced and rejected with an Error object in other case\n     */\n    async replaceTrack(track: MediaStreamTrack): Promise<void> {\n        return this.replaceTrackAux(track, true);\n    }\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    initialize(): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            let constraints: MediaStreamConstraints = {};\n            let constraintsAux: MediaStreamConstraints = {};\n            const timeForDialogEvent = 2000;\n            let startTime;\n\n            const errorCallback = (openViduError: OpenViduError) => {\n                this.accessDenied = true;\n                this.accessAllowed = false;\n                logger.error(`Publisher initialization failed. ${openViduError.name}: ${openViduError.message}`);\n                return reject(openViduError);\n            };\n\n            const successCallback = (mediaStream: MediaStream) => {\n                this.accessAllowed = true;\n                this.accessDenied = false;\n\n                if (typeof MediaStreamTrack !== 'undefined' && this.properties.audioSource instanceof MediaStreamTrack) {\n                    mediaStream.removeTrack(mediaStream.getAudioTracks()[0]);\n                    mediaStream.addTrack(<MediaStreamTrack>this.properties.audioSource);\n                }\n\n                if (typeof MediaStreamTrack !== 'undefined' && this.properties.videoSource instanceof MediaStreamTrack) {\n                    mediaStream.removeTrack(mediaStream.getVideoTracks()[0]);\n                    mediaStream.addTrack(<MediaStreamTrack>this.properties.videoSource);\n                }\n\n                // Apply PublisherProperties.publishAudio and PublisherProperties.publishVideo\n                if (!!mediaStream.getAudioTracks()[0]) {\n                    const enabled =\n                        this.stream.audioActive !== undefined && this.stream.audioActive !== null\n                            ? this.stream.audioActive\n                            : !!this.stream.outboundStreamOpts.publisherProperties.publishAudio;\n                    mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!mediaStream.getVideoTracks()[0]) {\n                    const enabled =\n                        this.stream.videoActive !== undefined && this.stream.videoActive !== null\n                            ? this.stream.videoActive\n                            : !!this.stream.outboundStreamOpts.publisherProperties.publishVideo;\n                    mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n\n                // Set Content Hint on all MediaStreamTracks\n                for (const track of mediaStream.getAudioTracks()) {\n                    if (!track.contentHint?.length) {\n                        // contentHint for audio: \"\", \"speech\", \"speech-recognition\", \"music\".\n                        // https://w3c.github.io/mst-content-hint/#audio-content-hints\n                        track.contentHint = '';\n                        logger.info(`Audio track Content Hint set: '${track.contentHint}'`);\n                    }\n                }\n                for (const track of mediaStream.getVideoTracks()) {\n                    if (!track.contentHint?.length) {\n                        // contentHint for video: \"\", \"motion\", \"detail\", \"text\".\n                        // https://w3c.github.io/mst-content-hint/#video-content-hints\n                        switch (this.stream.typeOfVideo) {\n                            case TypeOfVideo.SCREEN:\n                                track.contentHint = 'detail';\n                                break;\n                            case TypeOfVideo.CUSTOM:\n                                logger.warn('CUSTOM type video track was provided without Content Hint!');\n                                track.contentHint = 'motion';\n                                break;\n                            case TypeOfVideo.CAMERA:\n                            case TypeOfVideo.IPCAM:\n                            default:\n                                track.contentHint = 'motion';\n                                break;\n                        }\n                        logger.info(`Video track Content Hint set: '${track.contentHint}'`);\n                    }\n                }\n\n                this.initializeVideoReference(mediaStream);\n\n                if (!this.stream.displayMyRemote()) {\n                    // When we are subscribed to our remote we don't still set the MediaStream object in the video elements to\n                    // avoid early 'streamPlaying' event\n                    this.stream.updateMediaStreamInVideos();\n                }\n                delete this.firstVideoElement;\n\n                if (this.stream.isSendVideo()) {\n                    // Has video track\n                    this.getVideoDimensions().then((dimensions) => {\n                        this.stream.videoDimensions = {\n                            width: dimensions.width,\n                            height: dimensions.height\n                        };\n\n                        if (this.stream.isSendScreen()) {\n                            // Set interval to listen for screen resize events\n                            this.screenShareResizeInterval = setInterval(() => {\n                                const settings: MediaTrackSettings = mediaStream.getVideoTracks()[0].getSettings();\n                                const newWidth = settings.width;\n                                const newHeight = settings.height;\n                                const widthChanged = newWidth != null && newWidth !== this.stream.videoDimensions.width;\n                                const heightChanged = newHeight != null && newHeight !== this.stream.videoDimensions.height;\n                                if (this.stream.isLocalStreamPublished && (widthChanged || heightChanged)) {\n                                    this.openvidu.sendVideoDimensionsChangedEvent(\n                                        this,\n                                        'screenResized',\n                                        this.stream.videoDimensions.width,\n                                        this.stream.videoDimensions.height,\n                                        newWidth || 0,\n                                        newHeight || 0\n                                    );\n                                }\n                            }, 650);\n                        }\n\n                        this.stream.isLocalStreamReadyToPublish = true;\n                        this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                    });\n                } else {\n                    // Only audio track (no videoDimensions)\n                    this.stream.isLocalStreamReadyToPublish = true;\n                    this.stream.ee.emitEvent('stream-ready-to-publish', []);\n                }\n\n                return resolve();\n            };\n\n            const getMediaSuccess = async (mediaStream: MediaStream, definedAudioConstraint) => {\n                this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                if (this.stream.isSendScreen() && this.stream.isSendAudio()) {\n                    // When getting desktop as user media audio constraint must be false. Now we can ask for it if required\n                    constraintsAux.audio = definedAudioConstraint;\n                    constraintsAux.video = false;\n                    startTime = Date.now();\n                    this.setPermissionDialogTimer(timeForDialogEvent);\n\n                    try {\n                        const audioOnlyStream = await navigator.mediaDevices.getUserMedia(constraintsAux);\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.addTrack(audioOnlyStream.getAudioTracks()[0]);\n                        successCallback(mediaStream);\n                    } catch (error) {\n                        this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                        mediaStream.getAudioTracks().forEach((track) => {\n                            track.stop();\n                        });\n                        mediaStream.getVideoTracks().forEach((track) => {\n                            track.stop();\n                        });\n                        errorCallback(this.openvidu.generateAudioDeviceError(error, constraints));\n                        return;\n                    }\n                } else {\n                    successCallback(mediaStream);\n                }\n            };\n\n            const getMediaError = async (error) => {\n                logger.error(`getMediaError: ${error.toString()}`);\n                this.clearPermissionDialogTimer(startTime, timeForDialogEvent);\n                if (error.name === 'Error') {\n                    // Safari OverConstrainedError has as name property 'Error' instead of 'OverConstrainedError'\n                    error.name = error.constructor.name;\n                }\n                let errorName, errorMessage;\n                switch (error.name.toLowerCase()) {\n                    case 'notfounderror':\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: constraints.video\n                            });\n                            mediaStream.getVideoTracks().forEach((track) => {\n                                track.stop();\n                            });\n                            errorName = OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                            errorMessage = error.toString();\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        } catch (error) {\n                            errorName = OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                            errorMessage = error.toString();\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        }\n\n                        break;\n                    case 'notallowederror':\n                        errorName = this.stream.isSendScreen()\n                            ? OpenViduErrorName.SCREEN_CAPTURE_DENIED\n                            : OpenViduErrorName.DEVICE_ACCESS_DENIED;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                    case 'overconstrainederror':\n                        try {\n                            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                                audio: false,\n                                video: constraints.video\n                            });\n                            mediaStream.getVideoTracks().forEach((track) => {\n                                track.stop();\n                            });\n                            if (error.constraint.toLowerCase() === 'deviceid') {\n                                errorName = OpenViduErrorName.INPUT_AUDIO_DEVICE_NOT_FOUND;\n                                errorMessage =\n                                    \"Audio input device with deviceId '\" +\n                                    (<ConstrainDOMStringParameters>(<MediaTrackConstraints>constraints.audio).deviceId!!).exact +\n                                    \"' not found\";\n                            } else {\n                                errorName = OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                                errorMessage =\n                                    \"Audio input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                            }\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        } catch (error) {\n                            if (error.constraint.toLowerCase() === 'deviceid') {\n                                errorName = OpenViduErrorName.INPUT_VIDEO_DEVICE_NOT_FOUND;\n                                errorMessage =\n                                    \"Video input device with deviceId '\" +\n                                    (<ConstrainDOMStringParameters>(<MediaTrackConstraints>constraints.video).deviceId!!).exact +\n                                    \"' not found\";\n                            } else {\n                                errorName = OpenViduErrorName.PUBLISHER_PROPERTIES_ERROR;\n                                errorMessage =\n                                    \"Video input device doesn't support the value passed for constraint '\" + error.constraint + \"'\";\n                            }\n                            errorCallback(new OpenViduError(errorName, errorMessage));\n                        }\n\n                        break;\n                    case 'aborterror':\n                    case 'notreadableerror':\n                        errorName = OpenViduErrorName.DEVICE_ALREADY_IN_USE;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                    default:\n                        errorName = OpenViduErrorName.GENERIC_ERROR;\n                        errorMessage = error.toString();\n                        errorCallback(new OpenViduError(errorName, errorMessage));\n                        break;\n                }\n            };\n\n            try {\n                const myConstraints = await this.openvidu.generateMediaConstraints(this.properties);\n                if (\n                    (!!myConstraints.videoTrack && !!myConstraints.audioTrack) ||\n                    (!!myConstraints.audioTrack && myConstraints.constraints?.video === false) ||\n                    (!!myConstraints.videoTrack && myConstraints.constraints?.audio === false)\n                ) {\n                    // No need to call getUserMedia at all. MediaStreamTracks already provided\n                    successCallback(this.openvidu.addAlreadyProvidedTracks(myConstraints, new MediaStream(), this.stream));\n                } else {\n                    constraints = myConstraints.constraints;\n\n                    const outboundStreamOptions = {\n                        mediaConstraints: constraints,\n                        publisherProperties: this.properties\n                    };\n                    this.stream.setOutboundStreamOptions(outboundStreamOptions);\n\n                    const definedAudioConstraint = constraints.audio === undefined ? true : constraints.audio;\n                    constraintsAux.audio = this.stream.isSendScreen() ? false : definedAudioConstraint;\n                    constraintsAux.video = constraints.video;\n                    startTime = Date.now();\n                    this.setPermissionDialogTimer(timeForDialogEvent);\n\n                    try {\n                        if (this.stream.isSendScreen() && navigator.mediaDevices['getDisplayMedia'] && !platform.isElectron()) {\n                            const mediaStream = await navigator.mediaDevices['getDisplayMedia']({ video: true });\n                            this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream);\n                            await getMediaSuccess(mediaStream, definedAudioConstraint);\n                        } else {\n                            this.stream.lastVideoTrackConstraints = constraintsAux.video;\n                            const mediaStream = await navigator.mediaDevices.getUserMedia(constraintsAux);\n                            this.openvidu.addAlreadyProvidedTracks(myConstraints, mediaStream, this.stream);\n                            await getMediaSuccess(mediaStream, definedAudioConstraint);\n                        }\n                    } catch (error) {\n                        await getMediaError(error);\n                    }\n                }\n            } catch (error) {\n                errorCallback(error);\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    async replaceTrackAux(track: MediaStreamTrack, updateLastConstraints: boolean): Promise<void> {\n        // Set field \"enabled\" of the new track to the previous value\n        const trackOriginalEnabledValue: boolean = track.enabled;\n        if (track.kind === 'video') {\n            track.enabled = this.stream.videoActive;\n        } else if (track.kind === 'audio') {\n            track.enabled = this.stream.audioActive;\n        }\n        try {\n            if (this.stream.isLocalStreamPublished) {\n                // Only if the Publisher has been published is necessary to call native Web API RTCRtpSender.replaceTrack\n                // If it has not been published yet, replacing it on the MediaStream object is enough\n                this.replaceTrackInMediaStream(track, updateLastConstraints);\n                return await this.replaceTrackInRtcRtpSender(track);\n            } else {\n                // Publisher not published. Simply replace the track on the local MediaStream\n                return this.replaceTrackInMediaStream(track, updateLastConstraints);\n            }\n        } catch (error) {\n            track.enabled = trackOriginalEnabledValue;\n            throw error;\n        }\n    }\n\n    /**\n     * @hidden\n     *\n     * To obtain the videoDimensions we wait for the video reference to have enough metadata\n     * and then try to use MediaStreamTrack.getSettingsMethod(). If not available, then we\n     * use the HTMLVideoElement properties videoWidth and videoHeight\n     */\n    getVideoDimensions(): Promise<{ width: number; height: number }> {\n        return new Promise((resolve, reject) => {\n            // Ionic iOS and Safari iOS supposedly require the video element to actually exist inside the DOM\n            const requiresDomInsertion: boolean = platform.isIonicIos() || platform.isIOSWithSafari();\n\n            let loadedmetadataListener;\n            const resolveDimensions = () => {\n                let width: number;\n                let height: number;\n                if (typeof this.stream.getMediaStream().getVideoTracks()[0].getSettings === 'function') {\n                    const settings = this.stream.getMediaStream().getVideoTracks()[0].getSettings();\n                    width = settings.width || this.videoReference.videoWidth;\n                    height = settings.height || this.videoReference.videoHeight;\n                } else {\n                    logger.warn('MediaStreamTrack does not have getSettings method on ' + platform.getDescription());\n                    width = this.videoReference.videoWidth;\n                    height = this.videoReference.videoHeight;\n                }\n\n                if (loadedmetadataListener != null) {\n                    this.videoReference.removeEventListener('loadedmetadata', loadedmetadataListener);\n                }\n                if (requiresDomInsertion) {\n                    document.body.removeChild(this.videoReference);\n                }\n\n                return resolve({ width, height });\n            };\n\n            if (this.videoReference.readyState >= 1) {\n                // The video already has metadata available\n                // No need of loadedmetadata event\n                resolveDimensions();\n            } else {\n                // The video does not have metadata available yet\n                // Must listen to loadedmetadata event\n                loadedmetadataListener = () => {\n                    if (!this.videoReference.videoWidth) {\n                        let interval = setInterval(() => {\n                            if (!!this.videoReference.videoWidth) {\n                                clearInterval(interval);\n                                resolveDimensions();\n                            }\n                        }, 40);\n                    } else {\n                        resolveDimensions();\n                    }\n                };\n                this.videoReference.addEventListener('loadedmetadata', loadedmetadataListener);\n                if (requiresDomInsertion) {\n                    document.body.appendChild(this.videoReference);\n                }\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    reestablishStreamPlayingEvent() {\n        if (this.ee.getListeners('streamPlaying').length > 0) {\n            this.addPlayEventToFirstVideo();\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initializeVideoReference(mediaStream: MediaStream) {\n        this.videoReference = document.createElement('video');\n        this.videoReference.style.display = 'none';\n        this.videoReference.muted = true;\n        this.videoReference.autoplay = true;\n        this.videoReference.controls = false;\n        if (\n            platform.isSafariBrowser() ||\n            (platform.isIPhoneOrIPad() &&\n                (platform.isChromeMobileBrowser() ||\n                    platform.isEdgeMobileBrowser() ||\n                    platform.isOperaMobileBrowser() ||\n                    platform.isFirefoxMobileBrowser()))\n        ) {\n            this.videoReference.playsInline = true;\n        }\n        this.stream.setMediaStream(mediaStream);\n        if (!!this.firstVideoElement) {\n            this.createVideoElement(this.firstVideoElement.targetElement, <VideoInsertMode>this.properties.insertMode);\n        }\n        this.videoReference.srcObject = this.stream.getMediaStream();\n    }\n\n    /**\n     * @hidden\n     */\n    replaceTrackInMediaStream(track: MediaStreamTrack, updateLastConstraints: boolean): void {\n        const mediaStream: MediaStream = this.stream.displayMyRemote()\n            ? this.stream.localMediaStreamWhenSubscribedToRemote!\n            : this.stream.getMediaStream();\n        let removedTrack: MediaStreamTrack;\n        if (track.kind === 'video') {\n            removedTrack = mediaStream.getVideoTracks()[0];\n            if (updateLastConstraints) {\n                this.stream.lastVideoTrackConstraints = track.getConstraints();\n            }\n        } else {\n            removedTrack = mediaStream.getAudioTracks()[0];\n        }\n        removedTrack.enabled = false;\n        removedTrack.stop();\n        mediaStream.removeTrack(removedTrack);\n        mediaStream.addTrack(track);\n        const trackInfo = {\n            oldLabel: removedTrack?.label || '',\n            newLabel: track?.label || ''\n        };\n        if (track.kind === 'video' && updateLastConstraints) {\n            this.openvidu.sendNewVideoDimensionsIfRequired(this, 'trackReplaced', 50, 30);\n            this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'videoTrack');\n            if (this.stream.isLocalStreamPublished) {\n                this.session.sendVideoData(this.stream.streamManager, 5, true, 5);\n            }\n        } else if (track.kind === 'audio' && updateLastConstraints) {\n            this.openvidu.sendTrackChangedEvent(this, trackInfo.oldLabel, trackInfo.newLabel, 'audioTrack');\n        }\n        if (track.kind === 'audio') {\n            this.stream.disableHarkSpeakingEvent(false);\n            this.stream.disableHarkStoppedSpeakingEvent(false);\n            this.stream.disableHarkVolumeChangeEvent(false);\n            this.stream.initHarkEvents();\n        }\n    }\n\n    /* Private methods */\n\n    private setPermissionDialogTimer(waitTime: number): void {\n        this.permissionDialogTimeout = setTimeout(() => {\n            this.emitEvent('accessDialogOpened', []);\n        }, waitTime);\n    }\n\n    private clearPermissionDialogTimer(startTime: number, waitTime: number): void {\n        clearTimeout(this.permissionDialogTimeout);\n        if (Date.now() - startTime > waitTime) {\n            // Permission dialog was shown and now is closed\n            this.emitEvent('accessDialogClosed', []);\n        }\n    }\n\n    private async replaceTrackInRtcRtpSender(track: MediaStreamTrack): Promise<void> {\n        const senders: RTCRtpSender[] = this.stream.getRTCPeerConnection().getSenders();\n        let sender: RTCRtpSender | undefined;\n        if (track.kind === 'video') {\n            sender = senders.find((s) => !!s.track && s.track.kind === 'video');\n            if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n            }\n        } else if (track.kind === 'audio') {\n            sender = senders.find((s) => !!s.track && s.track.kind === 'audio');\n            if (!sender) {\n                throw new Error(\"There's no replaceable track for that kind of MediaStreamTrack in this Publisher object\");\n            }\n        } else {\n            throw new Error('Unknown track kind ' + track.kind);\n        }\n        await (sender as RTCRtpSender).replaceTrack(track);\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}