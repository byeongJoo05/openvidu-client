{"ast":null,"code":"\"use strict\";\n\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = void 0;\nvar Filter_1 = require(\"./Filter\");\nvar Subscriber_1 = require(\"./Subscriber\");\nvar WebRtcPeer_1 = require(\"../OpenViduInternal/WebRtcPeer/WebRtcPeer\");\nvar WebRtcStats_1 = require(\"../OpenViduInternal/WebRtcStats/WebRtcStats\");\nvar ExceptionEvent_1 = require(\"../OpenViduInternal/Events/ExceptionEvent\");\nvar PublisherSpeakingEvent_1 = require(\"../OpenViduInternal/Events/PublisherSpeakingEvent\");\nvar StreamManagerEvent_1 = require(\"../OpenViduInternal/Events/StreamManagerEvent\");\nvar StreamPropertyChangedEvent_1 = require(\"../OpenViduInternal/Events/StreamPropertyChangedEvent\");\nvar OpenViduError_1 = require(\"../OpenViduInternal/Enums/OpenViduError\");\nvar TypeOfVideo_1 = require(\"../OpenViduInternal/Enums/TypeOfVideo\");\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\nvar uuid_1 = require(\"uuid\");\n/**\n * @hidden\n */\nvar hark = require(\"hark\");\n/**\n * @hidden\n */\nvar EventEmitter = require(\"wolfy87-eventemitter\");\n/**\n * @hidden\n */\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\nvar platform;\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each {@link Publisher} and {@link Subscriber} has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\nvar Stream = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function Stream(session, options) {\n    var _this = this;\n    this.isSubscribeToRemote = false;\n    /**\n     * @hidden\n     */\n    this.isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n    this.isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n    this.publishedOnce = false;\n    /**\n     * @hidden\n     */\n    this.harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    this.harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    this.harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    this.harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    this.harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n    this.harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    this.ee = new EventEmitter();\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.session = session;\n    if (options.hasOwnProperty('id')) {\n      // InboundStreamOptions: stream belongs to a Subscriber\n      this.inboundStreamOpts = options;\n      this.streamId = this.inboundStreamOpts.id;\n      this.creationTime = this.inboundStreamOpts.createdAt;\n      this.hasAudio = this.inboundStreamOpts.hasAudio;\n      this.hasVideo = this.inboundStreamOpts.hasVideo;\n      if (this.hasAudio) {\n        this.audioActive = this.inboundStreamOpts.audioActive;\n      }\n      if (this.hasVideo) {\n        this.videoActive = this.inboundStreamOpts.videoActive;\n        this.typeOfVideo = !this.inboundStreamOpts.typeOfVideo ? undefined : this.inboundStreamOpts.typeOfVideo;\n        this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;\n        this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n      }\n      if (!!this.inboundStreamOpts.filter && Object.keys(this.inboundStreamOpts.filter).length > 0) {\n        if (!!this.inboundStreamOpts.filter.lastExecMethod && Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0) {\n          delete this.inboundStreamOpts.filter.lastExecMethod;\n        }\n        this.filter = this.inboundStreamOpts.filter;\n      }\n    } else {\n      // OutboundStreamOptions: stream belongs to a Publisher\n      this.outboundStreamOpts = options;\n      this.hasAudio = this.isSendAudio();\n      this.hasVideo = this.isSendVideo();\n      if (this.hasAudio) {\n        this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n      }\n      if (this.hasVideo) {\n        this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n        this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n        if (typeof MediaStreamTrack !== 'undefined' && this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack) {\n          this.typeOfVideo = TypeOfVideo_1.TypeOfVideo.CUSTOM;\n        } else {\n          this.typeOfVideo = this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n        }\n      }\n      if (!!this.outboundStreamOpts.publisherProperties.filter) {\n        this.filter = this.outboundStreamOpts.publisherProperties.filter;\n      }\n    }\n    this.ee.on('mediastream-updated', function () {\n      var _a;\n      _this.streamManager.updateMediaStream(_this.mediaStream);\n      logger.debug('Video srcObject [' + ((_a = _this.mediaStream) === null || _a === void 0 ? void 0 : _a.id) + '] updated in stream [' + _this.streamId + ']');\n    });\n  }\n  /**\n   * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n   * of a new one, that will apply the same properties.\n   *\n   * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n   * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n   */\n  Stream.prototype.reconnect = function () {\n    return this.reconnectStream('API');\n  };\n  /**\n   * Applies an audio/video filter to the stream.\n   *\n   * @param type Type of filter applied. See {@link Filter.type}\n   * @param options Parameters used to initialize the filter. See {@link Filter.options}\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n   */\n  Stream.prototype.applyFilter = function (type, options) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveApplyFilter, openviduToken_1, tokenParams_1, afterScriptLoaded_1, script, optionsString;\n        var _this = this;\n        return __generator(this, function (_a) {\n          if (!!this.filter) {\n            return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId))];\n          }\n          resolveApplyFilter = function resolveApplyFilter(error, triggerEvent) {\n            if (error) {\n              logger.error('Error applying filter for Stream ' + _this.streamId, error);\n              if (error.code === 401) {\n                return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\"));\n              } else {\n                return reject(error);\n              }\n            } else {\n              logger.info('Filter successfully applied on Stream ' + _this.streamId);\n              var oldValue = _this.filter;\n              _this.filter = new Filter_1.Filter(type, options);\n              _this.filter.stream = _this;\n              if (triggerEvent) {\n                _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n              }\n              return resolve(_this.filter);\n            }\n          };\n          if (type.startsWith('VB:')) {\n            // Client filters\n            if (!this.hasVideo) {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The Virtual Background filter requires a video track to be applied'))];\n            }\n            if (!this.mediaStream || this.streamManager.videos.length === 0) {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'))];\n            }\n            if (!!this.session.token) {\n              openviduToken_1 = this.session.token;\n            } else {\n              openviduToken_1 = options['token'];\n            }\n            if (!openviduToken_1) {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'))];\n            }\n            tokenParams_1 = this.session.getTokenParams(openviduToken_1);\n            if (tokenParams_1.edition !== 'pro' && tokenParams_1.edition !== 'enterprise') {\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, 'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'))];\n            }\n            openviduToken_1 = encodeURIComponent(btoa(openviduToken_1));\n            logger.info('Applying Virtual Background to stream ' + this.streamId);\n            afterScriptLoaded_1 = function afterScriptLoaded_1() {\n              return __awaiter(_this, void 0, void 0, function () {\n                var id, mediaStreamClone, videoClone, VB, filteredVideo, _a, error_1;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0, 8,, 9]);\n                      id = this.streamId + '_' + (0, uuid_1.v4)();\n                      mediaStreamClone = this.mediaStream.clone();\n                      videoClone = this.streamManager.videos[0].video.cloneNode(false);\n                      // @ts-ignore\n                      videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                      videoClone.srcObject = mediaStreamClone;\n                      videoClone.muted = true;\n                      this.virtualBackgroundSourceElements = {\n                        videoClone: videoClone,\n                        mediaStreamClone: mediaStreamClone\n                      };\n                      // @ts-ignore\n                      VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false);\n                      // @ts-ignore\n                      VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n                      return [4 /*yield*/, videoClone.play()];\n                    case 1:\n                      _b.sent();\n                      VB = new VirtualBackground.VirtualBackground({\n                        id: id,\n                        openviduServerUrl: new URL(tokenParams_1.httpUri),\n                        openviduToken: openviduToken_1,\n                        inputVideo: videoClone,\n                        inputResolution: '160x96',\n                        outputFramerate: 24\n                      });\n                      filteredVideo = void 0;\n                      _a = type;\n                      switch (_a) {\n                        case 'VB:blur':\n                          return [3 /*break*/, 2];\n                        case 'VB:image':\n                          return [3 /*break*/, 4];\n                      }\n                      return [3 /*break*/, 6];\n                    case 2:\n                      return [4 /*yield*/, VB.backgroundBlur(options)];\n                    case 3:\n                      filteredVideo = _b.sent();\n                      return [3 /*break*/, 7];\n                    case 4:\n                      return [4 /*yield*/, VB.backgroundImage(options)];\n                    case 5:\n                      filteredVideo = _b.sent();\n                      return [3 /*break*/, 7];\n                    case 6:\n                      throw new Error('Unknown Virtual Background filter: ' + type);\n                    case 7:\n                      this.virtualBackgroundSinkElements = {\n                        VB: VB,\n                        video: filteredVideo\n                      };\n                      videoClone.style.display = 'none';\n                      if (this.streamManager.remote) {\n                        this.streamManager.replaceTrackInMediaStream(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      } else {\n                        this.streamManager.replaceTrackAux(this.virtualBackgroundSinkElements.video.srcObject.getVideoTracks()[0], false);\n                      }\n                      resolveApplyFilter(undefined, false);\n                      return [3 /*break*/, 9];\n                    case 8:\n                      error_1 = _b.sent();\n                      if (error_1.name === OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                        resolveApplyFilter(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error_1.message), false);\n                      } else {\n                        resolveApplyFilter(error_1, false);\n                      }\n                      return [3 /*break*/, 9];\n                    case 9:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            };\n            // @ts-ignore\n            if (typeof VirtualBackground === 'undefined') {\n              script = document.createElement('script');\n              script.type = 'text/javascript';\n              script.src = tokenParams_1.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken_1;\n              script.onload = function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var error_2;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        _a.trys.push([0, 2,, 3]);\n                        return [4 /*yield*/, afterScriptLoaded_1()];\n                      case 1:\n                        _a.sent();\n                        resolve(new Filter_1.Filter(type, options));\n                        return [3 /*break*/, 3];\n                      case 2:\n                        error_2 = _a.sent();\n                        reject(error_2);\n                        return [3 /*break*/, 3];\n                      case 3:\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              };\n\n              document.body.appendChild(script);\n            } else {\n              afterScriptLoaded_1().then(function () {\n                return resolve(new Filter_1.Filter(type, options));\n              }).catch(function (error) {\n                return reject(error);\n              });\n            }\n          } else {\n            // Server filters\n            if (!this.session.sessionConnected()) {\n              return [2 /*return*/, reject(this.session.notConnectedError())];\n            }\n            logger.info('Applying server filter to stream ' + this.streamId);\n            options = options != null ? options : {};\n            optionsString = options;\n            if (typeof optionsString !== 'string') {\n              optionsString = JSON.stringify(optionsString);\n            }\n            this.session.openvidu.sendRequest('applyFilter', {\n              streamId: this.streamId,\n              type: type,\n              options: optionsString\n            }, function (error, response) {\n              resolveApplyFilter(error, true);\n            });\n          }\n          return [2 /*return*/];\n        });\n      });\n    });\n  };\n  /**\n   * Removes an audio/video filter previously applied.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n   */\n  Stream.prototype.removeFilter = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.removeFilterAux(false)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n   *\n   * @returns Native RTCPeerConnection Web API object\n   */\n  Stream.prototype.getRTCPeerConnection = function () {\n    return this.webRtcPeer.pc;\n  };\n  /**\n   * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n   *\n   * @returns Native MediaStream Web API object\n   */\n  Stream.prototype.getMediaStream = function () {\n    return this.mediaStream;\n  };\n  /* Hidden methods */\n  /**\n   * @hidden\n   */\n  Stream.prototype.removeFilterAux = function (isDisposing) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var resolveRemoveFilter, mediaStreamClone, error_3;\n        var _this = this;\n        var _a;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              resolveRemoveFilter = function resolveRemoveFilter(error, triggerEvent) {\n                if (error) {\n                  delete _this.filter;\n                  logger.error('Error removing filter for Stream ' + _this.streamId, error);\n                  if (error.code === 401) {\n                    return reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\"));\n                  } else {\n                    return reject(error);\n                  }\n                } else {\n                  logger.info('Filter successfully removed from Stream ' + _this.streamId);\n                  var oldValue = _this.filter;\n                  delete _this.filter;\n                  if (triggerEvent) {\n                    _this.session.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.session, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                    _this.streamManager.emitEvent('streamPropertyChanged', [new StreamPropertyChangedEvent_1.StreamPropertyChangedEvent(_this.streamManager, _this, 'filter', _this.filter, oldValue, 'applyFilter')]);\n                  }\n                  return resolve();\n                }\n              };\n              if (!!!this.filter) return [3 /*break*/, 11];\n              if (!((_a = this.filter) === null || _a === void 0 ? void 0 : _a.type.startsWith('VB:'))) return [3 /*break*/, 9];\n              _b.label = 1;\n            case 1:\n              _b.trys.push([1, 7,, 8]);\n              mediaStreamClone = this.virtualBackgroundSourceElements.mediaStreamClone;\n              if (!!isDisposing) return [3 /*break*/, 5];\n              if (!this.streamManager.remote) return [3 /*break*/, 2];\n              this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false);\n              return [3 /*break*/, 4];\n            case 2:\n              return [4 /*yield*/, this.streamManager.replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false)];\n            case 3:\n              _b.sent();\n              _b.label = 4;\n            case 4:\n              return [3 /*break*/, 6];\n            case 5:\n              mediaStreamClone.getTracks().forEach(function (track) {\n                return track.stop();\n              });\n              _b.label = 6;\n            case 6:\n              this.virtualBackgroundSinkElements.VB.cleanUp();\n              delete this.virtualBackgroundSinkElements;\n              delete this.virtualBackgroundSourceElements;\n              return [2 /*return*/, resolveRemoveFilter(undefined, false)];\n            case 7:\n              error_3 = _b.sent();\n              return [2 /*return*/, resolveRemoveFilter(error_3, false)];\n            case 8:\n              return [3 /*break*/, 10];\n            case 9:\n              // Server filters\n              if (!this.session.sessionConnected()) {\n                return [2 /*return*/, reject(this.session.notConnectedError())];\n              }\n              logger.info('Removing filter of stream ' + this.streamId);\n              this.session.openvidu.sendRequest('removeFilter', {\n                streamId: this.streamId\n              }, function (error, response) {\n                return resolveRemoveFilter(error, true);\n              });\n              _b.label = 10;\n            case 10:\n              return [3 /*break*/, 12];\n            case 11:\n              // There is no filter applied\n              return [2 /*return*/, reject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.GENERIC_ERROR, 'Stream ' + this.streamId + ' has no filter applied'))];\n            case 12:\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.setMediaStream = function (mediaStream) {\n    this.mediaStream = mediaStream;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.updateMediaStreamInVideos = function () {\n    this.ee.emitEvent('mediastream-updated', []);\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getWebRtcPeer = function () {\n    return this.webRtcPeer;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.subscribeToMyRemote = function (value) {\n    this.isSubscribeToRemote = value;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.setOutboundStreamOptions = function (outboundStreamOpts) {\n    this.outboundStreamOpts = outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.subscribe = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.initWebRtcPeerReceive(false).then(function () {\n        return resolve();\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.publish = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocalStreamReadyToPublish) {\n        _this.initWebRtcPeerSend(false).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      } else {\n        _this.ee.once('stream-ready-to-publish', function () {\n          _this.publish().then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disposeWebRtcPeer = function () {\n    var webrtcId;\n    if (!!this.webRtcPeer) {\n      this.webRtcPeer.dispose();\n      webrtcId = this.webRtcPeer.getId();\n    }\n    this.stopWebRtcStats();\n    logger.info((!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') + 'RTCPeerConnection with id [' + webrtcId + \"] from 'Stream' with id [\" + this.streamId + '] is now closed');\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disposeMediaStream = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(!!this.filter && this.filter.type.startsWith('VB:'))) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.removeFilterAux(true)];\n          case 2:\n            _a.sent();\n            console.debug(\"Success removing Virtual Background filter for stream \".concat(this.streamId));\n            return [3 /*break*/, 4];\n          case 3:\n            error_4 = _a.sent();\n            console.error(\"Error removing Virtual Background filter for stream \".concat(this.streamId), error_4);\n            return [3 /*break*/, 4];\n          case 4:\n            if (this.mediaStream) {\n              this.mediaStream.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.mediaStream.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.mediaStream;\n            }\n            // If subscribeToRemote local MediaStream must be stopped\n            if (this.localMediaStreamWhenSubscribedToRemote) {\n              this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach(function (track) {\n                track.stop();\n              });\n              this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach(function (track) {\n                track.stop();\n              });\n              delete this.localMediaStreamWhenSubscribedToRemote;\n            }\n            if (!!this.speechEvent) {\n              if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n              }\n              delete this.speechEvent;\n            }\n            logger.info((!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed');\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.displayMyRemote = function () {\n    return this.isSubscribeToRemote;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isSendAudio = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.audioSource !== null && this.outboundStreamOpts.publisherProperties.audioSource !== false;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isSendVideo = function () {\n    return !!this.outboundStreamOpts && this.outboundStreamOpts.publisherProperties.videoSource !== null && this.outboundStreamOpts.publisherProperties.videoSource !== false;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isSendScreen = function () {\n    var screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n    if (platform.isElectron()) {\n      screen = typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' && this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n    }\n    return !!this.outboundStreamOpts && screen;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableHarkSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n      this.harkSpeakingEnabled = true;\n      this.speechEvent.on('speaking', function () {\n        _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        _this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableOnceHarkSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = true;\n      this.speechEvent.once('speaking', function () {\n        if (_this.harkSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n          _this.streamManager.emitEvent('publisherStartSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStartSpeaking', _this.connection, _this.streamId)]);\n        }\n        _this.disableHarkSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disableHarkSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkSpeakingEnabledOnce = false;\n      if (disabledByOnce) {\n        if (this.harkSpeakingEnabled) {\n          // The 'on' version of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkSpeakingEnabled = false;\n      }\n      // Shutting down the hark event\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabled = true;\n      this.speechEvent.on('stopped_speaking', function () {\n        _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        _this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableOnceHarkStoppedSpeakingEvent = function () {\n    var _this = this;\n    this.setHarkListenerIfNotExists();\n    if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = true;\n      this.speechEvent.once('stopped_speaking', function () {\n        if (_this.harkStoppedSpeakingEnabledOnce) {\n          // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n          _this.session.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.session, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n          _this.streamManager.emitEvent('publisherStopSpeaking', [new PublisherSpeakingEvent_1.PublisherSpeakingEvent(_this.streamManager, 'publisherStopSpeaking', _this.connection, _this.streamId)]);\n        }\n        _this.disableHarkStoppedSpeakingEvent(true);\n      });\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disableHarkStoppedSpeakingEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkStoppedSpeakingEnabledOnce = false;\n      if (disabledByOnce) {\n        if (this.harkStoppedSpeakingEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkStoppedSpeakingEnabled = false;\n      }\n      // Shutting down the hark event\n      if (this.harkVolumeChangeEnabled || this.harkVolumeChangeEnabledOnce || this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('stopped_speaking');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabled || force) {\n        this.harkVolumeChangeEnabled = true;\n        this.speechEvent.on('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabled = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.enableOnceHarkVolumeChangeEvent = function (force) {\n    var _this = this;\n    if (this.setHarkListenerIfNotExists()) {\n      if (!this.harkVolumeChangeEnabledOnce || force) {\n        this.harkVolumeChangeEnabledOnce = true;\n        this.speechEvent.once('volume_change', function (harkEvent) {\n          var oldValue = _this.speechEvent.oldVolumeValue;\n          var value = {\n            newValue: harkEvent,\n            oldValue: oldValue\n          };\n          _this.speechEvent.oldVolumeValue = harkEvent;\n          _this.disableHarkVolumeChangeEvent(true);\n          _this.streamManager.emitEvent('streamAudioVolumeChange', [new StreamManagerEvent_1.StreamManagerEvent(_this.streamManager, 'streamAudioVolumeChange', value)]);\n        });\n      }\n    } else {\n      // This way whenever the MediaStream object is available, the event listener will be automatically added\n      this.harkVolumeChangeEnabledOnce = true;\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.disableHarkVolumeChangeEvent = function (disabledByOnce) {\n    if (!!this.speechEvent) {\n      this.harkVolumeChangeEnabledOnce = false;\n      if (disabledByOnce) {\n        if (this.harkVolumeChangeEnabled) {\n          // We are cancelling the 'once' listener for this event, but the 'on' version\n          // of this same event is enabled too. Do not remove the hark listener\n          return;\n        }\n      } else {\n        this.harkVolumeChangeEnabled = false;\n      }\n      // Shutting down the hark event\n      if (this.harkSpeakingEnabled || this.harkSpeakingEnabledOnce || this.harkStoppedSpeakingEnabled || this.harkStoppedSpeakingEnabledOnce) {\n        // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n        this.speechEvent.off('volume_change');\n      } else {\n        // No other hark event is enabled. We can get entirely rid of it\n        this.speechEvent.stop();\n        delete this.speechEvent;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.isLocal = function () {\n    // inbound options undefined and outbound options defined\n    return !this.inboundStreamOpts && !!this.outboundStreamOpts;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getSelectedIceCandidate = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.webRtcStats.getSelectedIceCandidateInfo().then(function (report) {\n        return resolve(report);\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getRemoteIceCandidateList = function () {\n    return this.webRtcPeer.remoteCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.getLocalIceCandidateList = function () {\n    return this.webRtcPeer.localCandidatesQueue;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.streamIceConnectionStateBroken = function () {\n    if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n      return false;\n    }\n    if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n      logger.warn(\"OpenVidu Browser advanced configuration option \\\"forceMediaReconnectionAfterNetworkDrop\\\" is enabled. Stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") will force a reconnection\"));\n      return true;\n    }\n    var iceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n    return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n  };\n  /* Private methods */\n  Stream.prototype.setHarkListenerIfNotExists = function () {\n    if (!!this.mediaStream) {\n      if (!this.speechEvent) {\n        var harkOptions = !!this.harkOptions ? this.harkOptions : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n        harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;\n        harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;\n        this.speechEvent = hark(this.mediaStream, harkOptions);\n      }\n      return true;\n    }\n    return false;\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.setupReconnectionEventEmitter = function (resolve, reject) {\n    if (this.reconnectionEventEmitter == undefined) {\n      // There is no ongoing reconnection\n      this.reconnectionEventEmitter = new EventEmitter();\n      return false;\n    } else {\n      // Ongoing reconnection\n      console.warn(\"Trying to reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but an ongoing reconnection process is active. Waiting for response...\"));\n      this.reconnectionEventEmitter.once('success', function () {\n        return resolve();\n      });\n      this.reconnectionEventEmitter.once('error', function (error) {\n        return reject(error);\n      });\n      return true;\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerSend = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var _a;\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      } else {\n        // MediaStream will already have hark events for reconnected streams\n        _this.initHarkEvents(); // Init hark events for the local stream\n      }\n\n      var finalResolve = function finalResolve() {\n        var _a;\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n          delete _this.reconnectionEventEmitter;\n        }\n        return resolve();\n      };\n      var finalReject = function finalReject(error) {\n        var _a;\n        if (reconnect) {\n          (_a = _this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n          delete _this.reconnectionEventEmitter;\n        }\n        return reject(error);\n      };\n      var successOfferCallback = function successOfferCallback(sdpOfferParam) {\n        logger.debug('Sending SDP offer to publish as ' + _this.streamId, sdpOfferParam);\n        var method = reconnect ? 'reconnectStream' : 'publishVideo';\n        var params;\n        if (reconnect) {\n          params = {\n            stream: _this.streamId,\n            sdpString: sdpOfferParam\n          };\n        } else {\n          var typeOfVideo = void 0;\n          if (_this.isSendVideo()) {\n            typeOfVideo = typeof MediaStreamTrack !== 'undefined' && _this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack ? TypeOfVideo_1.TypeOfVideo.CUSTOM : _this.isSendScreen() ? TypeOfVideo_1.TypeOfVideo.SCREEN : TypeOfVideo_1.TypeOfVideo.CAMERA;\n          }\n          params = {\n            doLoopback: _this.displayMyRemote() || false,\n            hasAudio: _this.isSendAudio(),\n            hasVideo: _this.isSendVideo(),\n            audioActive: _this.audioActive,\n            videoActive: _this.videoActive,\n            typeOfVideo: typeOfVideo,\n            frameRate: !!_this.frameRate ? _this.frameRate : -1,\n            videoDimensions: JSON.stringify(_this.videoDimensions),\n            filter: _this.outboundStreamOpts.publisherProperties.filter,\n            sdpOffer: sdpOfferParam\n          };\n        }\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            if (error.code === 401) {\n              finalReject(new OpenViduError_1.OpenViduError(OpenViduError_1.OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\"));\n            } else {\n              finalReject('Error on publishVideo: ' + JSON.stringify(error));\n            }\n          } else {\n            _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n              _this.streamId = response.id;\n              _this.creationTime = response.createdAt;\n              _this.isLocalStreamPublished = true;\n              _this.publishedOnce = true;\n              if (_this.displayMyRemote()) {\n                _this.localMediaStreamWhenSubscribedToRemote = _this.mediaStream;\n                _this.remotePeerSuccessfullyEstablished(reconnect);\n              }\n              if (reconnect) {\n                _this.ee.emitEvent('stream-reconnected-by-publisher', []);\n              } else {\n                _this.ee.emitEvent('stream-created-by-publisher', []);\n              }\n              _this.initWebRtcStats();\n              logger.info(\"'Publisher' (\" + _this.streamId + ') successfully ' + (reconnect ? 'reconnected' : 'published') + ' to session');\n              finalResolve();\n            }).catch(function (error) {\n              finalReject(error);\n            });\n          }\n        });\n      };\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: (_a = _this.outboundStreamOpts.publisherProperties.videoSimulcast) !== null && _a !== void 0 ? _a : _this.session.openvidu.videoSimulcast,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: _this.onIceConnectionStateExceptionHandler.bind(_this),\n        iceServers: _this.getIceServersConf(),\n        mediaStream: _this.mediaStream,\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n      if (_this.session.openvidu.mediaServer !== 'mediasoup') {\n        // Simulcast is only supported by mediasoup\n        config.simulcast = false;\n      }\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n      if (_this.displayMyRemote()) {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendrecv(config);\n      } else {\n        _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerSendonly(config);\n      }\n      _this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + _this.connection.connectionId);\n      _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n        _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n          successOfferCallback(sdpOffer.sdp);\n        }).catch(function (error) {\n          finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n        });\n      }).catch(function (error) {\n        finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.finalResolveForSubscription = function (reconnect, resolve) {\n    var _a;\n    logger.info(\"'Subscriber' (\" + this.streamId + ') successfully ' + (reconnect ? 'reconnected' : 'subscribed'));\n    this.remotePeerSuccessfullyEstablished(reconnect);\n    this.initWebRtcStats();\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('success');\n      delete this.reconnectionEventEmitter;\n    }\n    return resolve();\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.finalRejectForSubscription = function (reconnect, error, reject) {\n    var _a;\n    logger.error(\"Error for 'Subscriber' (\" + this.streamId + ') while trying to ' + (reconnect ? 'reconnect' : 'subscribe') + ': ' + error.toString());\n    if (reconnect) {\n      (_a = this.reconnectionEventEmitter) === null || _a === void 0 ? void 0 : _a.emitEvent('error', [error]);\n      delete this.reconnectionEventEmitter;\n    }\n    return reject(error);\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerReceive = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (reconnect) {\n        if (_this.setupReconnectionEventEmitter(resolve, reject)) {\n          // Ongoing reconnection\n          return;\n        }\n      }\n      if (_this.session.openvidu.mediaServer === 'mediasoup') {\n        // Server initiates negotiation\n        _this.initWebRtcPeerReceiveFromServer(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      } else {\n        // Client initiates negotiation\n        _this.initWebRtcPeerReceiveFromClient(reconnect).then(function () {\n          return _this.finalResolveForSubscription(reconnect, resolve);\n        }).catch(function (error) {\n          return _this.finalRejectForSubscription(reconnect, error, reject);\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerReceiveFromClient = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this.completeWebRtcPeerReceive(reconnect, false).then(function (response) {\n        _this.webRtcPeer.processRemoteAnswer(response.sdpAnswer).then(function () {\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      }).catch(function (error) {\n        return reject(error);\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcPeerReceiveFromServer = function (reconnect) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // Server initiates negotiation\n      _this.session.openvidu.sendRequest('prepareReceiveVideoFrom', {\n        sender: _this.streamId,\n        reconnect: reconnect\n      }, function (error, response) {\n        if (error) {\n          return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n        } else {\n          _this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer).then(function () {\n            return resolve();\n          }).catch(function (error) {\n            return reject(error);\n          });\n        }\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.completeWebRtcPeerReceive = function (reconnect, forciblyReconnect, sdpOfferByServer) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      logger.debug(\"'Session.subscribe(Stream)' called\");\n      var sendSdpToServer = function sendSdpToServer(sdpString) {\n        logger.debug(\"Sending local SDP \".concat(!!sdpOfferByServer ? 'answer' : 'offer', \" to subscribe to \").concat(_this.streamId), sdpString);\n        var method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n        var params = {};\n        params[reconnect ? 'stream' : 'sender'] = _this.streamId;\n        if (!!sdpOfferByServer) {\n          params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n        } else {\n          params['sdpOffer'] = sdpString;\n        }\n        if (reconnect) {\n          params['forciblyReconnect'] = forciblyReconnect;\n        }\n        _this.session.openvidu.sendRequest(method, params, function (error, response) {\n          if (error) {\n            return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n          } else {\n            return resolve(response);\n          }\n        });\n      };\n      var config = {\n        mediaConstraints: {\n          audio: _this.hasAudio,\n          video: _this.hasVideo\n        },\n        simulcast: false,\n        onIceCandidate: _this.connection.sendIceCandidate.bind(_this.connection),\n        onIceConnectionStateException: _this.onIceConnectionStateExceptionHandler.bind(_this),\n        iceServers: _this.getIceServersConf(),\n        mediaServer: _this.session.openvidu.mediaServer,\n        typeOfVideo: _this.typeOfVideo ? TypeOfVideo_1.TypeOfVideo[_this.typeOfVideo] : undefined\n      };\n      if (reconnect) {\n        _this.disposeWebRtcPeer();\n      }\n      _this.webRtcPeer = new WebRtcPeer_1.WebRtcPeerRecvonly(config);\n      _this.webRtcPeer.addIceConnectionStateChangeListener(_this.streamId);\n      if (!!sdpOfferByServer) {\n        _this.webRtcPeer.processRemoteOffer(sdpOfferByServer).then(function () {\n          _this.webRtcPeer.createAnswer().then(function (sdpAnswer) {\n            _this.webRtcPeer.processLocalAnswer(sdpAnswer).then(function () {\n              sendSdpToServer(sdpAnswer.sdp);\n            }).catch(function (error) {\n              return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n            });\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n        });\n      } else {\n        _this.webRtcPeer.createOffer().then(function (sdpOffer) {\n          _this.webRtcPeer.processLocalOffer(sdpOffer).then(function () {\n            sendSdpToServer(sdpOffer.sdp);\n          }).catch(function (error) {\n            return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n          });\n        }).catch(function (error) {\n          return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n        });\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.remotePeerSuccessfullyEstablished = function (reconnect) {\n    if (reconnect && this.mediaStream != null) {\n      // Now we can destroy the existing MediaStream\n      this.disposeMediaStream();\n    }\n    this.mediaStream = new MediaStream();\n    var receiver;\n    for (var _i = 0, _a = this.webRtcPeer.pc.getReceivers(); _i < _a.length; _i++) {\n      receiver = _a[_i];\n      if (!!receiver.track) {\n        this.mediaStream.addTrack(receiver.track);\n      }\n    }\n    logger.debug('Peer remote stream', this.mediaStream);\n    if (!!this.mediaStream) {\n      if (this.streamManager instanceof Subscriber_1.Subscriber) {\n        // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n        if (!!this.mediaStream.getAudioTracks()[0]) {\n          var enabled = reconnect ? this.audioActive : !!this.streamManager.properties.subscribeToAudio;\n          this.mediaStream.getAudioTracks()[0].enabled = enabled;\n        }\n        if (!!this.mediaStream.getVideoTracks()[0]) {\n          var enabled = reconnect ? this.videoActive : !!this.streamManager.properties.subscribeToVideo;\n          this.mediaStream.getVideoTracks()[0].enabled = enabled;\n        }\n      }\n      this.updateMediaStreamInVideos();\n      this.initHarkEvents(); // Init hark events for the remote stream\n    }\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initHarkEvents = function () {\n    if (!!this.mediaStream.getAudioTracks()[0]) {\n      // Hark events can only be set if audio track is available\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkSpeakingEvent();\n      }\n      if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n        this.enableHarkSpeakingEvent();\n      }\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n        this.enableOnceHarkStoppedSpeakingEvent();\n      }\n      if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n        this.enableHarkStoppedSpeakingEvent();\n      }\n      if (this.harkVolumeChangeEnabledOnce) {\n        this.enableOnceHarkVolumeChangeEvent(true);\n      }\n      if (this.harkVolumeChangeEnabled) {\n        this.enableHarkVolumeChangeEvent(true);\n      }\n    }\n  };\n  Stream.prototype.onIceConnectionStateExceptionHandler = function (exceptionName, message, data) {\n    switch (exceptionName) {\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED:\n        this.onIceConnectionFailed();\n        break;\n      case ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n        this.onIceConnectionDisconnected();\n        break;\n    }\n    this.session.emitEvent('exception', [new ExceptionEvent_1.ExceptionEvent(this.session, exceptionName, this, message, data)]);\n  };\n  Stream.prototype.onIceConnectionFailed = function () {\n    // Immediately reconnect, as this is a terminal error\n    logger.log(\"[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \")\"));\n    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_FAILED);\n  };\n  Stream.prototype.onIceConnectionDisconnected = function () {\n    var _this = this;\n    // Wait to see if the ICE connection is able to reconnect\n    logger.log(\"[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream \".concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") if not possible\"));\n    var timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n    this.awaitWebRtcPeerConnectionState(timeout).then(function (state) {\n      switch (state) {\n        case 'failed':\n          // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") is now failed after ICE_CONNECTION_DISCONNECTED\"));\n          break;\n        case 'connected':\n        case 'completed':\n          logger.log(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: \").concat(state));\n          break;\n        case 'closed':\n        case 'checking':\n        case 'new':\n        case 'disconnected':\n          // Rest of states\n          logger.warn(\"[ICE_CONNECTION_DISCONNECTED] ICE connection of stream \".concat(_this.streamId, \" (\").concat(_this.isLocal() ? 'Publisher' : 'Subscriber', \") couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after \").concat(timeout, \" ms: \").concat(state));\n          _this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEvent_1.ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n          break;\n      }\n    });\n  };\n  Stream.prototype.reconnectStreamAndLogResultingIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var finalIceStateAfterReconnection, error_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.reconnectStreamAndReturnIceConnectionState(event)];\n          case 1:\n            finalIceStateAfterReconnection = _a.sent();\n            switch (finalIceStateAfterReconnection) {\n              case 'connected':\n              case 'completed':\n                logger.log(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") successfully reconnected after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n              default:\n                logger.error(\"[\".concat(event, \"] Stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") failed to reconnect after \").concat(event, \". Current ICE connection state: \").concat(finalIceStateAfterReconnection));\n                break;\n            }\n            return [3 /*break*/, 3];\n          case 2:\n            error_5 = _a.sent();\n            logger.error(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after \").concat(event, \": \").concat(error_5));\n            return [3 /*break*/, 3];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.reconnectStreamAndReturnIceConnectionState = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var timeout, error_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.log(\"[\".concat(event, \"] Reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") after event \").concat(event));\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.reconnectStream(event)];\n          case 2:\n            _a.sent();\n            timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return [2 /*return*/, this.awaitWebRtcPeerConnectionState(timeout)];\n          case 3:\n            error_6 = _a.sent();\n            logger.warn(\"[\".concat(event, \"] Error reconnecting stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \"). Reason: \").concat(error_6));\n            return [2 /*return*/, this.awaitWebRtcPeerConnectionState(1)];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.awaitWebRtcPeerConnectionState = function (timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n      var state, interval, intervals, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            state = this.getRTCPeerConnection().iceConnectionState;\n            interval = 150;\n            intervals = Math.ceil(timeout / interval);\n            i = 0;\n            _a.label = 1;\n          case 1:\n            if (!(i < intervals)) return [3 /*break*/, 4];\n            state = this.getRTCPeerConnection().iceConnectionState;\n            if (state === 'connected' || state === 'completed') {\n              return [3 /*break*/, 4];\n            }\n            // Sleep\n            return [4 /*yield*/, new Promise(function (resolve) {\n              return setTimeout(resolve, interval);\n            })];\n          case 2:\n            // Sleep\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            i++;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, state];\n        }\n      });\n    });\n  };\n  Stream.prototype.reconnectStream = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isWsConnected, errorMsg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.isWebsocketConnected(event, 3000)];\n          case 1:\n            isWsConnected = _a.sent();\n            if (isWsConnected) {\n              // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n              logger.log(\"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") and the websocket is opened\"));\n              if (this.isLocal()) {\n                return [2 /*return*/, this.initWebRtcPeerSend(true)];\n              } else {\n                return [2 /*return*/, this.initWebRtcPeerReceive(true)];\n              }\n            } else {\n              errorMsg = \"[\".concat(event, \"] Trying to reconnect stream \").concat(this.streamId, \" (\").concat(this.isLocal() ? 'Publisher' : 'Subscriber', \") but the websocket wasn't opened\");\n              logger.error(errorMsg);\n              throw Error(errorMsg);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Stream.prototype.isWebsocketConnected = function (event, msResponseTimeout) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var wsReadyState = _this.session.openvidu.getWsReadyState();\n      if (wsReadyState === 1) {\n        var responseTimeout_1 = setTimeout(function () {\n          console.warn(\"[\".concat(event, \"] Websocket timeout of \").concat(msResponseTimeout, \"ms\"));\n          return resolve(false);\n        }, msResponseTimeout);\n        _this.session.openvidu.sendRequest('echo', {}, function (error, response) {\n          clearTimeout(responseTimeout_1);\n          if (!!error) {\n            console.warn(\"[\".concat(event, \"] Websocket 'echo' returned error: \").concat(error));\n            return resolve(false);\n          } else {\n            return resolve(true);\n          }\n        });\n      } else {\n        console.warn(\"[\".concat(event, \"] Websocket readyState is \").concat(wsReadyState));\n        return resolve(false);\n      }\n    });\n  };\n  /**\n   * @hidden\n   */\n  Stream.prototype.initWebRtcStats = function () {\n    this.webRtcStats = new WebRtcStats_1.WebRtcStats(this);\n    this.webRtcStats.initWebRtcStats();\n    //TODO: send common webrtc stats from client to openvidu-server\n    /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n        setInterval(() => {\n            this.gatherStatsForPeer().then(jsonStats => {\n                const body = {\n                    sessionId: this.session.sessionId,\n                    participantPrivateId: this.connection.rpcSessionId,\n                    stats: jsonStats\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                xhr.setRequestHeader('Content-Type', 'application/json');\n                xhr.send(JSON.stringify(body));\n            })\n        }, this.session.openvidu.webrtcStatsInterval * 1000);\n    }*/\n  };\n\n  Stream.prototype.stopWebRtcStats = function () {\n    if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n      this.webRtcStats.stopWebRtcStats();\n    }\n  };\n  Stream.prototype.getIceServersConf = function () {\n    var returnValue;\n    if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n      returnValue = this.session.openvidu.advancedConfiguration.iceServers === 'freeice' ? undefined : this.session.openvidu.advancedConfiguration.iceServers;\n    } else if (this.session.openvidu.iceServers) {\n      returnValue = this.session.openvidu.iceServers;\n    } else {\n      returnValue = undefined;\n    }\n    return returnValue;\n  };\n  Stream.prototype.gatherStatsForPeer = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.isLocal()) {\n        // Publisher stream stats\n        _this.getRTCPeerConnection().getSenders().forEach(function (sender) {\n          return sender.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id;\n                // Common to Chrome, Firefox and Safari\n                if (report.type === 'outbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum;\n                  // Set media type\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesEncoded'] = report.framesEncoded;\n                  }\n                  finalReport['packetsSent'] = report.packetsSent;\n                  finalReport['bytesSent'] = report.bytesSent;\n                }\n                // Only for Chrome and Safari\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                }\n                // Only for Firefox >= 66.0\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      } else {\n        // Subscriber stream stats\n        _this.getRTCPeerConnection().getReceivers().forEach(function (receiver) {\n          return receiver.getStats().then(function (response) {\n            response.forEach(function (report) {\n              if (_this.isReportWanted(report)) {\n                var finalReport = {};\n                finalReport['type'] = report.type;\n                finalReport['timestamp'] = report.timestamp;\n                finalReport['id'] = report.id;\n                // Common to Chrome, Firefox and Safari\n                if (report.type === 'inbound-rtp') {\n                  finalReport['ssrc'] = report.ssrc;\n                  finalReport['firCount'] = report.firCount;\n                  finalReport['pliCount'] = report.pliCount;\n                  finalReport['nackCount'] = report.nackCount;\n                  finalReport['qpSum'] = report.qpSum;\n                  // Set media type\n                  if (!!report.kind) {\n                    finalReport['mediaType'] = report.kind;\n                  } else if (!!report.mediaType) {\n                    finalReport['mediaType'] = report.mediaType;\n                  } else {\n                    // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                    finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                  }\n                  if (finalReport['mediaType'] === 'video') {\n                    finalReport['framesDecoded'] = report.framesDecoded;\n                  }\n                  finalReport['packetsReceived'] = report.packetsReceived;\n                  finalReport['packetsLost'] = report.packetsLost;\n                  finalReport['jitter'] = report.jitter;\n                  finalReport['bytesReceived'] = report.bytesReceived;\n                }\n                // Only for Chrome and Safari\n                if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                  // This is the final selected candidate pair\n                  finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                  finalReport['rtt'] = report.currentRoundTripTime;\n                  finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                }\n                // Only for Firefox >= 66.0\n                if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {}\n                logger.log(finalReport);\n              }\n            });\n          });\n        });\n      }\n    });\n  };\n  Stream.prototype.isReportWanted = function (report) {\n    return report.type === 'inbound-rtp' && !this.isLocal() || report.type === 'outbound-rtp' && this.isLocal() || report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0;\n  };\n  return Stream;\n}();\nexports.Stream = Stream;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","session","options","EventEmitter","Platform_1","hasOwnProperty","inboundStreamOpts","streamId","id","creationTime","createdAt","hasAudio","hasVideo","audioActive","videoActive","typeOfVideo","undefined","frameRate","videoDimensions","filter","Object","keys","length","lastExecMethod","outboundStreamOpts","isSendAudio","isSendVideo","publisherProperties","publishAudio","publishVideo","MediaStreamTrack","videoSource","TypeOfVideo_1","CUSTOM","isSendScreen","SCREEN","CAMERA","ee","on","_this","streamManager","updateMediaStream","mediaStream","debug","Stream","reconnectStream","type","Promise","resolve","reject","OpenViduError_1","GENERIC_ERROR","resolveApplyFilter","error","triggerEvent","code","OPENVIDU_PERMISSION_DENIED","info","oldValue","Filter_1","stream","emitEvent","StreamPropertyChangedEvent_1","startsWith","VIRTUAL_BACKGROUND_ERROR","videos","token","openviduToken_1","tokenParams_1","getTokenParams","edition","encodeURIComponent","btoa","afterScriptLoaded_1","mediaStreamClone","clone","videoClone","video","cloneNode","VirtualBackground","SOURCE_VIDEO_PREFIX","srcObject","muted","virtualBackgroundSourceElements","hideHtmlElement","appendHtmlElementToHiddenContainer","play","_b","VB","openviduServerUrl","URL","httpUri","openviduToken","inputVideo","inputResolution","outputFramerate","filteredVideo","_a","backgroundBlur","backgroundImage","Error","virtualBackgroundSinkElements","style","display","remote","replaceTrackInMediaStream","getVideoTracks","replaceTrackAux","error_1","name","message","script","document","createElement","src","onload","error_2","body","appendChild","then","catch","sessionConnected","notConnectedError","optionsString","JSON","stringify","openvidu","sendRequest","response","removeFilterAux","webRtcPeer","pc","isDisposing","resolveRemoveFilter","getTracks","forEach","track","stop","cleanUp","error_3","value","isSubscribeToRemote","initWebRtcPeerReceive","isLocalStreamReadyToPublish","initWebRtcPeerSend","once","publish","webrtcId","dispose","getId","stopWebRtcStats","console","error_4","getAudioTracks","localMediaStreamWhenSubscribedToRemote","speechEvent","audioSource","screen","isElectron","setHarkListenerIfNotExists","harkSpeakingEnabled","PublisherSpeakingEvent_1","connection","harkSpeakingEnabledOnce","disableHarkSpeakingEvent","disabledByOnce","harkVolumeChangeEnabled","harkVolumeChangeEnabledOnce","harkStoppedSpeakingEnabled","harkStoppedSpeakingEnabledOnce","off","disableHarkStoppedSpeakingEvent","force","harkEvent","oldVolumeValue","newValue","StreamManagerEvent_1","disableHarkVolumeChangeEvent","webRtcStats","getSelectedIceCandidateInfo","report","remoteCandidatesQueue","localCandidatesQueue","getWebRtcPeer","getRTCPeerConnection","isLocal","advancedConfiguration","forceMediaReconnectionAfterNetworkDrop","warn","iceConnectionState","harkOptions","publisherSpeakingEventsOptions","interval","threshold","hark","reconnectionEventEmitter","reconnect","setupReconnectionEventEmitter","initHarkEvents","finalResolve","finalReject","successOfferCallback","sdpOfferParam","method","params","sdpString","doLoopback","displayMyRemote","sdpOffer","processRemoteAnswer","sdpAnswer","isLocalStreamPublished","publishedOnce","remotePeerSuccessfullyEstablished","initWebRtcStats","config","mediaConstraints","audio","simulcast","videoSimulcast","onIceCandidate","sendIceCandidate","bind","onIceConnectionStateException","onIceConnectionStateExceptionHandler","iceServers","getIceServersConf","mediaServer","disposeWebRtcPeer","WebRtcPeer_1","addIceConnectionStateChangeListener","connectionId","createOffer","processLocalOffer","sdp","toString","initWebRtcPeerReceiveFromServer","finalResolveForSubscription","finalRejectForSubscription","initWebRtcPeerReceiveFromClient","completeWebRtcPeerReceive","sender","forciblyReconnect","sdpOfferByServer","sendSdpToServer","processRemoteOffer","createAnswer","processLocalAnswer","disposeMediaStream","MediaStream","receiver","getReceivers","_i","addTrack","Subscriber_1","enabled","properties","subscribeToAudio","subscribeToVideo","updateMediaStreamInVideos","anySpeechEventListenerEnabled","enableOnceHarkSpeakingEvent","enableHarkSpeakingEvent","enableOnceHarkStoppedSpeakingEvent","enableHarkStoppedSpeakingEvent","enableOnceHarkVolumeChangeEvent","enableHarkVolumeChangeEvent","exceptionName","data","ExceptionEvent_1","ICE_CONNECTION_FAILED","onIceConnectionFailed","ICE_CONNECTION_DISCONNECTED","onIceConnectionDisconnected","log","reconnectStreamAndLogResultingIceConnectionState","timeout","iceConnectionDisconnectedExceptionTimeout","awaitWebRtcPeerConnectionState","state","event","reconnectStreamAndReturnIceConnectionState","finalIceStateAfterReconnection","error_5","error_6","intervals","Math","ceil","i","isWebsocketConnected","isWsConnected","errorMsg","msResponseTimeout","wsReadyState","getWsReadyState","responseTimeout_1","setTimeout","clearTimeout","WebRtcStats_1","isEnabled","returnValue","getSenders","getStats","isReportWanted","finalReport","timestamp","ssrc","firCount","pliCount","nackCount","qpSum","kind","mediaType","indexOf","framesEncoded","packetsSent","bytesSent","totalRoundTripTime","availableOutgoingBitrate","currentRoundTripTime","responsesReceived","framesDecoded","packetsReceived","packetsLost","jitter","bytesReceived","availableIncomingBitrate","nominated","exports"],"sources":["C:\\Users\\user\\Desktop\\openvidu-client\\node_modules\\openvidu-browser\\src\\OpenVidu\\Stream.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Connection } from './Connection';\nimport { Filter } from './Filter';\nimport { Publisher } from './Publisher';\nimport { Session } from './Session';\nimport { StreamManager } from './StreamManager';\nimport { Subscriber } from './Subscriber';\nimport { InboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/InboundStreamOptions';\nimport { OutboundStreamOptions } from '../OpenViduInternal/Interfaces/Private/OutboundStreamOptions';\nimport {\n    WebRtcPeer,\n    WebRtcPeerSendonly,\n    WebRtcPeerRecvonly,\n    WebRtcPeerSendrecv,\n    WebRtcPeerConfiguration\n} from '../OpenViduInternal/WebRtcPeer/WebRtcPeer';\nimport { WebRtcStats } from '../OpenViduInternal/WebRtcStats/WebRtcStats';\nimport { ExceptionEvent, ExceptionEventName } from '../OpenViduInternal/Events/ExceptionEvent';\nimport { PublisherSpeakingEvent } from '../OpenViduInternal/Events/PublisherSpeakingEvent';\nimport { StreamManagerEvent } from '../OpenViduInternal/Events/StreamManagerEvent';\nimport { StreamPropertyChangedEvent } from '../OpenViduInternal/Events/StreamPropertyChangedEvent';\nimport { OpenViduError, OpenViduErrorName } from '../OpenViduInternal/Enums/OpenViduError';\nimport { TypeOfVideo } from '../OpenViduInternal/Enums/TypeOfVideo';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\n\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * @hidden\n */\nimport hark = require('hark');\n/**\n * @hidden\n */\nimport EventEmitter = require('wolfy87-eventemitter');\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Represents each one of the media streams available in OpenVidu Server for certain session.\n * Each {@link Publisher} and {@link Subscriber} has an attribute of type Stream, as they give access\n * to one of them (sending and receiving it, respectively)\n */\nexport class Stream {\n    /**\n     * The Connection object that is publishing the stream\n     */\n    connection: Connection;\n\n    /**\n     * Frame rate of the video in frames per second. This property is only defined if the {@link Publisher} of\n     * the stream was initialized passing a _frameRate_ property on {@link OpenVidu.initPublisher} method\n     */\n    frameRate?: number;\n\n    /**\n     * Whether the stream has a video track or not\n     */\n    hasVideo: boolean;\n\n    /**\n     * Whether the stream has an audio track or not\n     */\n    hasAudio: boolean;\n\n    /**\n     * Whether the stream has the video track muted or unmuted. If {@link hasVideo} is false, this property is undefined.\n     *\n     * This property may change if the Publisher publishing the stream calls {@link Publisher.publishVideo}. Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched\n     * by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    videoActive: boolean;\n\n    /**\n     * Whether the stream has the audio track muted or unmuted. If {@link hasAudio} is false, this property is undefined\n     *\n     * This property may change if the Publisher publishing the stream calls {@link Publisher.publishAudio}. Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched\n     * by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    audioActive: boolean;\n\n    /**\n     * Unique identifier of the stream. If the stream belongs to a...\n     * - Subscriber object: property `streamId` is always defined\n     * - Publisher object: property `streamId` is only defined after successful execution of {@link Session.publish}\n     */\n    streamId: string;\n\n    /**\n     * Time when this stream was created in OpenVidu Server (UTC milliseconds). Depending on the owner of this stream:\n     * - Subscriber object: property `creationTime` is always defined\n     * - Publisher object: property `creationTime` is only defined after successful execution of {@link Session.publish}\n     */\n    creationTime: number;\n\n    /**\n     * Can be:\n     * - `\"CAMERA\"`: when the video source comes from a webcam.\n     * - `\"SCREEN\"`: when the video source comes from screen-sharing.\n     * - `\"CUSTOM\"`: when {@link PublisherProperties.videoSource} has been initialized in the Publisher side with a custom MediaStreamTrack when calling {@link OpenVidu.initPublisher}).\n     * - `\"IPCAM\"`: when the video source comes from an IP camera participant instead of a regular participant (see [IP cameras](/en/stable/advanced-features/ip-cameras/)).\n     *\n     * If {@link hasVideo} is false, this property is undefined\n     */\n    typeOfVideo?: keyof typeof TypeOfVideo; // TODO: Change this type to enum TypeOfVideo on the next breaking-change release\n\n    /**\n     * StreamManager object ({@link Publisher} or {@link Subscriber}) in charge of displaying this stream in the DOM\n     */\n    streamManager: StreamManager;\n\n    /**\n     * Width and height in pixels of the encoded video stream. If {@link hasVideo} is false, this property is undefined\n     *\n     * This property may change if the Publisher that is publishing:\n     * - If it is a mobile device, whenever the user rotates the device.\n     * - If it is screen-sharing, whenever the user changes the size of the captured window.\n     *\n     * Whenever this happens a {@link StreamPropertyChangedEvent} will be dispatched by the Session object as well as by the affected Subscriber/Publisher object\n     */\n    videoDimensions: { width: number; height: number };\n\n    /**\n     * **WARNING**: experimental option. This interface may change in the near future\n     *\n     * Filter applied to the Stream. You can apply filters by calling {@link Stream.applyFilter}, execute methods of the applied filter with\n     * {@link Filter.execMethod} and remove it with {@link Stream.removeFilter}. Be aware that the client calling this methods must have the\n     * necessary permissions: the token owned by the client must have been initialized with the appropriated `allowedFilters` array.\n     */\n    filter?: Filter;\n\n    protected webRtcPeer: WebRtcPeer;\n    protected mediaStream?: MediaStream;\n    private webRtcStats: WebRtcStats;\n\n    private isSubscribeToRemote = false;\n\n    private virtualBackgroundSourceElements?: { videoClone: HTMLVideoElement; mediaStreamClone: MediaStream };\n    /**\n     * @hidden\n     */\n    virtualBackgroundSinkElements?: { VB: any; video: HTMLVideoElement };\n\n    /**\n     * @hidden\n     */\n    isLocalStreamReadyToPublish = false;\n    /**\n     * @hidden\n     */\n    isLocalStreamPublished = false;\n    /**\n     * @hidden\n     */\n    publishedOnce = false;\n    /**\n     * @hidden\n     */\n    session: Session;\n    /**\n     * @hidden\n     */\n    inboundStreamOpts: InboundStreamOptions;\n    /**\n     * @hidden\n     */\n    outboundStreamOpts: OutboundStreamOptions;\n    /**\n     * @hidden\n     */\n    speechEvent: any;\n    /**\n     * @hidden\n     */\n    harkSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    harkSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkStoppedSpeakingEnabled = false;\n    /**\n     * @hidden\n     */\n    harkStoppedSpeakingEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkVolumeChangeEnabled = false;\n    /**\n     * @hidden\n     */\n    harkVolumeChangeEnabledOnce = false;\n    /**\n     * @hidden\n     */\n    harkOptions;\n    /**\n     * @hidden\n     */\n    localMediaStreamWhenSubscribedToRemote?: MediaStream;\n    /**\n     * @hidden\n     */\n    ee = new EventEmitter();\n    /**\n     * @hidden\n     */\n    reconnectionEventEmitter: EventEmitter | undefined;\n    /**\n     * @hidden\n     */\n    lastVideoTrackConstraints: MediaTrackConstraints | boolean | undefined;\n    /**\n     * @hidden\n     */\n    lastVBFilter?: Filter;\n\n    /**\n     * @hidden\n     */\n    constructor(session: Session, options: InboundStreamOptions | OutboundStreamOptions | {}) {\n        platform = PlatformUtils.getInstance();\n        this.session = session;\n\n        if (options.hasOwnProperty('id')) {\n            // InboundStreamOptions: stream belongs to a Subscriber\n            this.inboundStreamOpts = <InboundStreamOptions>options;\n            this.streamId = this.inboundStreamOpts.id;\n            this.creationTime = this.inboundStreamOpts.createdAt;\n            this.hasAudio = this.inboundStreamOpts.hasAudio;\n            this.hasVideo = this.inboundStreamOpts.hasVideo;\n            if (this.hasAudio) {\n                this.audioActive = this.inboundStreamOpts.audioActive;\n            }\n            if (this.hasVideo) {\n                this.videoActive = this.inboundStreamOpts.videoActive;\n                this.typeOfVideo = !this.inboundStreamOpts.typeOfVideo ? undefined : this.inboundStreamOpts.typeOfVideo;\n                this.frameRate = this.inboundStreamOpts.frameRate === -1 ? undefined : this.inboundStreamOpts.frameRate;\n                this.videoDimensions = this.inboundStreamOpts.videoDimensions;\n            }\n            if (!!this.inboundStreamOpts.filter && Object.keys(this.inboundStreamOpts.filter).length > 0) {\n                if (\n                    !!this.inboundStreamOpts.filter.lastExecMethod &&\n                    Object.keys(this.inboundStreamOpts.filter.lastExecMethod).length === 0\n                ) {\n                    delete this.inboundStreamOpts.filter.lastExecMethod;\n                }\n                this.filter = this.inboundStreamOpts.filter;\n            }\n        } else {\n            // OutboundStreamOptions: stream belongs to a Publisher\n            this.outboundStreamOpts = <OutboundStreamOptions>options;\n\n            this.hasAudio = this.isSendAudio();\n            this.hasVideo = this.isSendVideo();\n\n            if (this.hasAudio) {\n                this.audioActive = !!this.outboundStreamOpts.publisherProperties.publishAudio;\n            }\n            if (this.hasVideo) {\n                this.videoActive = !!this.outboundStreamOpts.publisherProperties.publishVideo;\n                this.frameRate = this.outboundStreamOpts.publisherProperties.frameRate;\n                if (\n                    typeof MediaStreamTrack !== 'undefined' &&\n                    this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack\n                ) {\n                    this.typeOfVideo = TypeOfVideo.CUSTOM;\n                } else {\n                    this.typeOfVideo = this.isSendScreen() ? TypeOfVideo.SCREEN : TypeOfVideo.CAMERA;\n                }\n            }\n            if (!!this.outboundStreamOpts.publisherProperties.filter) {\n                this.filter = this.outboundStreamOpts.publisherProperties.filter;\n            }\n        }\n\n        this.ee.on('mediastream-updated', () => {\n            this.streamManager.updateMediaStream(this.mediaStream!);\n            logger.debug('Video srcObject [' + this.mediaStream?.id + '] updated in stream [' + this.streamId + ']');\n        });\n    }\n\n    /**\n     * Recreates the media connection with the server. This entails the disposal of the previous RTCPeerConnection and the re-negotiation\n     * of a new one, that will apply the same properties.\n     *\n     * This method can be useful in those situations were there the media connection breaks and OpenVidu is not able to recover on its own\n     * for any kind of unanticipated reason (see [Automatic reconnection](/en/stable/advanced-features/automatic-reconnection/)).\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the reconnection operation was successful and rejected with an Error object if not\n     */\n    public reconnect(): Promise<void> {\n        return this.reconnectStream('API');\n    }\n\n    /**\n     * Applies an audio/video filter to the stream.\n     *\n     * @param type Type of filter applied. See {@link Filter.type}\n     * @param options Parameters used to initialize the filter. See {@link Filter.options}\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved to the applied filter if success and rejected with an Error object if not\n     */\n    applyFilter(type: string, options: Object): Promise<Filter> {\n        return new Promise(async (resolve, reject) => {\n            if (!!this.filter) {\n                return reject(\n                    new OpenViduError(OpenViduErrorName.GENERIC_ERROR, 'There is already a filter applied to Stream ' + this.streamId)\n                );\n            }\n\n            const resolveApplyFilter = (error, triggerEvent) => {\n                if (error) {\n                    logger.error('Error applying filter for Stream ' + this.streamId, error);\n                    if (error.code === 401) {\n                        return reject(\n                            new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to apply a filter\")\n                        );\n                    } else {\n                        return reject(error);\n                    }\n                } else {\n                    logger.info('Filter successfully applied on Stream ' + this.streamId);\n                    const oldValue: Filter = this.filter!;\n                    this.filter = new Filter(type, options);\n                    this.filter.stream = this;\n                    if (triggerEvent) {\n                        this.session.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.session, this, 'filter', this.filter, oldValue, 'applyFilter')\n                        ]);\n                        this.streamManager.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.streamManager, this, 'filter', this.filter, oldValue, 'applyFilter')\n                        ]);\n                    }\n                    return resolve(this.filter);\n                }\n            };\n\n            if (type.startsWith('VB:')) {\n                // Client filters\n\n                if (!this.hasVideo) {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'The Virtual Background filter requires a video track to be applied'\n                        )\n                    );\n                }\n                if (!this.mediaStream || this.streamManager.videos.length === 0) {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'The StreamManager requires some video element to be attached to it in order to apply a Virtual Background filter'\n                        )\n                    );\n                }\n\n                let openviduToken: string;\n                if (!!this.session.token) {\n                    openviduToken = this.session.token;\n                } else {\n                    openviduToken = options['token'];\n                }\n                if (!openviduToken) {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'Virtual Background requires the client to be connected to a Session or to have a \"token\" property available in \"options\" parameter with a valid OpenVidu token'\n                        )\n                    );\n                }\n\n                const tokenParams = this.session.getTokenParams(openviduToken);\n                if (tokenParams.edition !== 'pro' && tokenParams.edition !== 'enterprise') {\n                    return reject(\n                        new OpenViduError(\n                            OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR,\n                            'OpenVidu Virtual Background API is available from OpenVidu Pro edition onwards'\n                        )\n                    );\n                }\n\n                openviduToken = encodeURIComponent(btoa(openviduToken));\n\n                logger.info('Applying Virtual Background to stream ' + this.streamId);\n\n                const afterScriptLoaded = async () => {\n                    try {\n                        const id = this.streamId + '_' + uuidv4();\n                        const mediaStreamClone = this.mediaStream!.clone();\n                        const videoClone = this.streamManager.videos[0].video.cloneNode(false) as HTMLVideoElement;\n                        // @ts-ignore\n                        videoClone.id = VirtualBackground.VirtualBackground.SOURCE_VIDEO_PREFIX + id;\n                        videoClone.srcObject = mediaStreamClone;\n                        videoClone.muted = true;\n                        this.virtualBackgroundSourceElements = { videoClone, mediaStreamClone };\n\n                        // @ts-ignore\n                        VirtualBackground.VirtualBackground.hideHtmlElement(videoClone, false);\n                        // @ts-ignore\n                        VirtualBackground.VirtualBackground.appendHtmlElementToHiddenContainer(videoClone, id);\n\n                        await videoClone.play();\n\n                        // @ts-ignore\n                        const VB = new VirtualBackground.VirtualBackground({\n                            id,\n                            openviduServerUrl: new URL(tokenParams.httpUri),\n                            openviduToken,\n                            inputVideo: videoClone,\n                            inputResolution: '160x96',\n                            outputFramerate: 24\n                        });\n\n                        let filteredVideo: HTMLVideoElement;\n                        switch (type) {\n                            case 'VB:blur': {\n                                filteredVideo = await VB.backgroundBlur(options);\n                                break;\n                            }\n                            case 'VB:image': {\n                                filteredVideo = await VB.backgroundImage(options);\n                                break;\n                            }\n                            default:\n                                throw new Error('Unknown Virtual Background filter: ' + type);\n                        }\n\n                        this.virtualBackgroundSinkElements = { VB, video: filteredVideo };\n\n                        videoClone.style.display = 'none';\n\n                        if (this.streamManager.remote) {\n                            this.streamManager.replaceTrackInMediaStream(\n                                (this.virtualBackgroundSinkElements.video.srcObject as MediaStream).getVideoTracks()[0],\n                                false\n                            );\n                        } else {\n                            (this.streamManager as Publisher).replaceTrackAux(\n                                (this.virtualBackgroundSinkElements.video.srcObject as MediaStream).getVideoTracks()[0],\n                                false\n                            );\n                        }\n\n                        resolveApplyFilter(undefined, false);\n                    } catch (error) {\n                        if (error.name === OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR) {\n                            resolveApplyFilter(new OpenViduError(OpenViduErrorName.VIRTUAL_BACKGROUND_ERROR, error.message), false);\n                        } else {\n                            resolveApplyFilter(error, false);\n                        }\n                    }\n                };\n\n                // @ts-ignore\n                if (typeof VirtualBackground === 'undefined') {\n                    let script: HTMLScriptElement = document.createElement('script');\n                    script.type = 'text/javascript';\n                    script.src = tokenParams.httpUri + '/openvidu/virtual-background/openvidu-virtual-background.js?token=' + openviduToken;\n                    script.onload = async () => {\n                        try {\n                            await afterScriptLoaded();\n                            resolve(new Filter(type, options));\n                        } catch (error) {\n                            reject(error);\n                        }\n                    };\n                    document.body.appendChild(script);\n                } else {\n                    afterScriptLoaded()\n                        .then(() => resolve(new Filter(type, options)))\n                        .catch((error) => reject(error));\n                }\n            } else {\n                // Server filters\n\n                if (!this.session.sessionConnected()) {\n                    return reject(this.session.notConnectedError());\n                }\n\n                logger.info('Applying server filter to stream ' + this.streamId);\n                options = options != null ? options : {};\n                let optionsString = options;\n                if (typeof optionsString !== 'string') {\n                    optionsString = JSON.stringify(optionsString);\n                }\n                this.session.openvidu.sendRequest(\n                    'applyFilter',\n                    { streamId: this.streamId, type, options: optionsString },\n                    (error, response) => {\n                        resolveApplyFilter(error, true);\n                    }\n                );\n            }\n        });\n    }\n\n    /**\n     * Removes an audio/video filter previously applied.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the previously applied filter has been successfully removed and rejected with an Error object in other case\n     */\n    async removeFilter(): Promise<void> {\n        return await this.removeFilterAux(false);\n    }\n\n    /**\n     * Returns the internal RTCPeerConnection object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n     *\n     * @returns Native RTCPeerConnection Web API object\n     */\n    getRTCPeerConnection(): RTCPeerConnection {\n        return this.webRtcPeer.pc;\n    }\n\n    /**\n     * Returns the internal MediaStream object associated to this stream (https://developer.mozilla.org/en-US/docs/Web/API/MediaStream)\n     *\n     * @returns Native MediaStream Web API object\n     */\n    getMediaStream(): MediaStream {\n        return this.mediaStream!;\n    }\n\n    /* Hidden methods */\n\n    /**\n     * @hidden\n     */\n    removeFilterAux(isDisposing: boolean): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            const resolveRemoveFilter = (error, triggerEvent) => {\n                if (error) {\n                    delete this.filter;\n                    logger.error('Error removing filter for Stream ' + this.streamId, error);\n                    if (error.code === 401) {\n                        return reject(\n                            new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to remove a filter\")\n                        );\n                    } else {\n                        return reject(error);\n                    }\n                } else {\n                    logger.info('Filter successfully removed from Stream ' + this.streamId);\n                    const oldValue = this.filter!;\n                    delete this.filter;\n                    if (triggerEvent) {\n                        this.session.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.session, this, 'filter', this.filter!, oldValue, 'applyFilter')\n                        ]);\n                        this.streamManager.emitEvent('streamPropertyChanged', [\n                            new StreamPropertyChangedEvent(this.streamManager, this, 'filter', this.filter!, oldValue, 'applyFilter')\n                        ]);\n                    }\n                    return resolve();\n                }\n            };\n\n            if (!!this.filter) {\n                // There is a filter applied\n\n                if (this.filter?.type.startsWith('VB:')) {\n                    // Client filters\n\n                    try {\n                        const mediaStreamClone = this.virtualBackgroundSourceElements!.mediaStreamClone;\n                        if (!isDisposing) {\n                            if (this.streamManager.remote) {\n                                this.streamManager.replaceTrackInMediaStream(mediaStreamClone.getVideoTracks()[0], false);\n                            } else {\n                                await (this.streamManager as Publisher).replaceTrackAux(mediaStreamClone.getVideoTracks()[0], false);\n                            }\n                        } else {\n                            mediaStreamClone.getTracks().forEach((track) => track.stop());\n                        }\n\n                        this.virtualBackgroundSinkElements!.VB.cleanUp();\n\n                        delete this.virtualBackgroundSinkElements;\n                        delete this.virtualBackgroundSourceElements;\n\n                        return resolveRemoveFilter(undefined, false);\n                    } catch (error) {\n                        return resolveRemoveFilter(error, false);\n                    }\n                } else {\n                    // Server filters\n\n                    if (!this.session.sessionConnected()) {\n                        return reject(this.session.notConnectedError());\n                    }\n\n                    logger.info('Removing filter of stream ' + this.streamId);\n                    this.session.openvidu.sendRequest('removeFilter', { streamId: this.streamId }, (error, response) => {\n                        return resolveRemoveFilter(error, true);\n                    });\n                }\n            } else {\n                // There is no filter applied\n                return reject(new OpenViduError(OpenViduErrorName.GENERIC_ERROR, 'Stream ' + this.streamId + ' has no filter applied'));\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    setMediaStream(mediaStream: MediaStream): void {\n        this.mediaStream = mediaStream;\n    }\n\n    /**\n     * @hidden\n     */\n    updateMediaStreamInVideos() {\n        this.ee.emitEvent('mediastream-updated', []);\n    }\n\n    /**\n     * @hidden\n     */\n    getWebRtcPeer(): WebRtcPeer {\n        return this.webRtcPeer;\n    }\n\n    /**\n     * @hidden\n     */\n    subscribeToMyRemote(value: boolean): void {\n        this.isSubscribeToRemote = value;\n    }\n\n    /**\n     * @hidden\n     */\n    setOutboundStreamOptions(outboundStreamOpts: OutboundStreamOptions): void {\n        this.outboundStreamOpts = outboundStreamOpts;\n    }\n\n    /**\n     * @hidden\n     */\n    subscribe(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.initWebRtcPeerReceive(false)\n                .then(() => resolve())\n                .catch((error) => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    publish(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (this.isLocalStreamReadyToPublish) {\n                this.initWebRtcPeerSend(false)\n                    .then(() => resolve())\n                    .catch((error) => reject(error));\n            } else {\n                this.ee.once('stream-ready-to-publish', () => {\n                    this.publish()\n                        .then(() => resolve())\n                        .catch((error) => reject(error));\n                });\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    disposeWebRtcPeer(): void {\n        let webrtcId;\n        if (!!this.webRtcPeer) {\n            this.webRtcPeer.dispose();\n            webrtcId = this.webRtcPeer.getId();\n        }\n        this.stopWebRtcStats();\n        logger.info(\n            (!!this.outboundStreamOpts ? 'Outbound ' : 'Inbound ') +\n            'RTCPeerConnection with id [' +\n            webrtcId +\n            \"] from 'Stream' with id [\" +\n            this.streamId +\n            '] is now closed'\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    async disposeMediaStream(): Promise<void> {\n        if (!!this.filter && this.filter.type.startsWith('VB:')) {\n            try {\n                await this.removeFilterAux(true);\n                console.debug(`Success removing Virtual Background filter for stream ${this.streamId}`);\n            } catch (error) {\n                console.error(`Error removing Virtual Background filter for stream ${this.streamId}`, error);\n            }\n        }\n        if (this.mediaStream) {\n            this.mediaStream.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this.mediaStream.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n            delete this.mediaStream;\n        }\n        // If subscribeToRemote local MediaStream must be stopped\n        if (this.localMediaStreamWhenSubscribedToRemote) {\n            this.localMediaStreamWhenSubscribedToRemote.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this.localMediaStreamWhenSubscribedToRemote.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n            delete this.localMediaStreamWhenSubscribedToRemote;\n        }\n        if (!!this.speechEvent) {\n            if (!!this.speechEvent.stop) {\n                this.speechEvent.stop();\n            }\n            delete this.speechEvent;\n        }\n        logger.info(\n            (!!this.outboundStreamOpts ? 'Local ' : 'Remote ') + \"MediaStream from 'Stream' with id [\" + this.streamId + '] is now disposed'\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    displayMyRemote(): boolean {\n        return this.isSubscribeToRemote;\n    }\n\n    /**\n     * @hidden\n     */\n    isSendAudio(): boolean {\n        return (\n            !!this.outboundStreamOpts &&\n            this.outboundStreamOpts.publisherProperties.audioSource !== null &&\n            this.outboundStreamOpts.publisherProperties.audioSource !== false\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    isSendVideo(): boolean {\n        return (\n            !!this.outboundStreamOpts &&\n            this.outboundStreamOpts.publisherProperties.videoSource !== null &&\n            this.outboundStreamOpts.publisherProperties.videoSource !== false\n        );\n    }\n\n    /**\n     * @hidden\n     */\n    isSendScreen(): boolean {\n        let screen = this.outboundStreamOpts.publisherProperties.videoSource === 'screen';\n        if (platform.isElectron()) {\n            screen =\n                typeof this.outboundStreamOpts.publisherProperties.videoSource === 'string' &&\n                this.outboundStreamOpts.publisherProperties.videoSource.startsWith('screen:');\n        }\n        return !!this.outboundStreamOpts && screen;\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkSpeakingEnabled && !!this.speechEvent) {\n            this.harkSpeakingEnabled = true;\n            this.speechEvent.on('speaking', () => {\n                this.session.emitEvent('publisherStartSpeaking', [\n                    new PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)\n                ]);\n                this.streamManager.emitEvent('publisherStartSpeaking', [\n                    new PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)\n                ]);\n                this.harkSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkSpeakingEnabledOnce && !!this.speechEvent) {\n            this.harkSpeakingEnabledOnce = true;\n            this.speechEvent.once('speaking', () => {\n                if (this.harkSpeakingEnabledOnce) {\n                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n                    this.session.emitEvent('publisherStartSpeaking', [\n                        new PublisherSpeakingEvent(this.session, 'publisherStartSpeaking', this.connection, this.streamId)\n                    ]);\n                    this.streamManager.emitEvent('publisherStartSpeaking', [\n                        new PublisherSpeakingEvent(this.streamManager, 'publisherStartSpeaking', this.connection, this.streamId)\n                    ]);\n                }\n                this.disableHarkSpeakingEvent(true);\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkSpeakingEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkSpeakingEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkSpeakingEnabled) {\n                    // The 'on' version of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkSpeakingEnabled = false;\n            }\n            // Shutting down the hark event\n            if (\n                this.harkVolumeChangeEnabled ||\n                this.harkVolumeChangeEnabledOnce ||\n                this.harkStoppedSpeakingEnabled ||\n                this.harkStoppedSpeakingEnabledOnce\n            ) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('speaking');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkStoppedSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkStoppedSpeakingEnabled && !!this.speechEvent) {\n            this.harkStoppedSpeakingEnabled = true;\n            this.speechEvent.on('stopped_speaking', () => {\n                this.session.emitEvent('publisherStopSpeaking', [\n                    new PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)\n                ]);\n                this.streamManager.emitEvent('publisherStopSpeaking', [\n                    new PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)\n                ]);\n                this.harkStoppedSpeakingEnabledOnce = false; // Disable 'once' version if 'on' version was triggered\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkStoppedSpeakingEvent(): void {\n        this.setHarkListenerIfNotExists();\n        if (!this.harkStoppedSpeakingEnabledOnce && !!this.speechEvent) {\n            this.harkStoppedSpeakingEnabledOnce = true;\n            this.speechEvent.once('stopped_speaking', () => {\n                if (this.harkStoppedSpeakingEnabledOnce) {\n                    // If the listener has been disabled in the meantime (for example by the 'on' version) do not trigger the event\n                    this.session.emitEvent('publisherStopSpeaking', [\n                        new PublisherSpeakingEvent(this.session, 'publisherStopSpeaking', this.connection, this.streamId)\n                    ]);\n                    this.streamManager.emitEvent('publisherStopSpeaking', [\n                        new PublisherSpeakingEvent(this.streamManager, 'publisherStopSpeaking', this.connection, this.streamId)\n                    ]);\n                }\n                this.disableHarkStoppedSpeakingEvent(true);\n            });\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkStoppedSpeakingEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkStoppedSpeakingEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkStoppedSpeakingEnabled) {\n                    // We are cancelling the 'once' listener for this event, but the 'on' version\n                    // of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkStoppedSpeakingEnabled = false;\n            }\n            // Shutting down the hark event\n            if (\n                this.harkVolumeChangeEnabled ||\n                this.harkVolumeChangeEnabledOnce ||\n                this.harkSpeakingEnabled ||\n                this.harkSpeakingEnabledOnce\n            ) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('stopped_speaking');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableHarkVolumeChangeEvent(force: boolean): void {\n        if (this.setHarkListenerIfNotExists()) {\n            if (!this.harkVolumeChangeEnabled || force) {\n                this.harkVolumeChangeEnabled = true;\n                this.speechEvent.on('volume_change', (harkEvent) => {\n                    const oldValue = this.speechEvent.oldVolumeValue;\n                    const value = { newValue: harkEvent, oldValue };\n                    this.speechEvent.oldVolumeValue = harkEvent;\n                    this.streamManager.emitEvent('streamAudioVolumeChange', [\n                        new StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)\n                    ]);\n                });\n            }\n        } else {\n            // This way whenever the MediaStream object is available, the event listener will be automatically added\n            this.harkVolumeChangeEnabled = true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    enableOnceHarkVolumeChangeEvent(force: boolean): void {\n        if (this.setHarkListenerIfNotExists()) {\n            if (!this.harkVolumeChangeEnabledOnce || force) {\n                this.harkVolumeChangeEnabledOnce = true;\n                this.speechEvent.once('volume_change', (harkEvent) => {\n                    const oldValue = this.speechEvent.oldVolumeValue;\n                    const value = { newValue: harkEvent, oldValue };\n                    this.speechEvent.oldVolumeValue = harkEvent;\n                    this.disableHarkVolumeChangeEvent(true);\n                    this.streamManager.emitEvent('streamAudioVolumeChange', [\n                        new StreamManagerEvent(this.streamManager, 'streamAudioVolumeChange', value)\n                    ]);\n                });\n            }\n        } else {\n            // This way whenever the MediaStream object is available, the event listener will be automatically added\n            this.harkVolumeChangeEnabledOnce = true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    disableHarkVolumeChangeEvent(disabledByOnce: boolean): void {\n        if (!!this.speechEvent) {\n            this.harkVolumeChangeEnabledOnce = false;\n            if (disabledByOnce) {\n                if (this.harkVolumeChangeEnabled) {\n                    // We are cancelling the 'once' listener for this event, but the 'on' version\n                    // of this same event is enabled too. Do not remove the hark listener\n                    return;\n                }\n            } else {\n                this.harkVolumeChangeEnabled = false;\n            }\n            // Shutting down the hark event\n            if (\n                this.harkSpeakingEnabled ||\n                this.harkSpeakingEnabledOnce ||\n                this.harkStoppedSpeakingEnabled ||\n                this.harkStoppedSpeakingEnabledOnce\n            ) {\n                // Some other hark event is enabled. Cannot stop the hark process, just remove the specific listener\n                this.speechEvent.off('volume_change');\n            } else {\n                // No other hark event is enabled. We can get entirely rid of it\n                this.speechEvent.stop();\n                delete this.speechEvent;\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    isLocal(): boolean {\n        // inbound options undefined and outbound options defined\n        return !this.inboundStreamOpts && !!this.outboundStreamOpts;\n    }\n\n    /**\n     * @hidden\n     */\n    getSelectedIceCandidate(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.webRtcStats\n                .getSelectedIceCandidateInfo()\n                .then((report) => resolve(report))\n                .catch((error) => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    getRemoteIceCandidateList(): RTCIceCandidate[] {\n        return this.webRtcPeer.remoteCandidatesQueue;\n    }\n\n    /**\n     * @hidden\n     */\n    getLocalIceCandidateList(): RTCIceCandidate[] {\n        return this.webRtcPeer.localCandidatesQueue;\n    }\n\n    /**\n     * @hidden\n     */\n    streamIceConnectionStateBroken() {\n        if (!this.getWebRtcPeer() || !this.getRTCPeerConnection()) {\n            return false;\n        }\n        if (this.isLocal() && !!this.session.openvidu.advancedConfiguration.forceMediaReconnectionAfterNetworkDrop) {\n            logger.warn(\n                `OpenVidu Browser advanced configuration option \"forceMediaReconnectionAfterNetworkDrop\" is enabled. Stream ${this.streamId\n                } (${this.isLocal() ? 'Publisher' : 'Subscriber'}) will force a reconnection`\n            );\n            return true;\n        }\n        const iceConnectionState: RTCIceConnectionState = this.getRTCPeerConnection().iceConnectionState;\n        return iceConnectionState !== 'connected' && iceConnectionState !== 'completed';\n    }\n\n    /* Private methods */\n\n    private setHarkListenerIfNotExists(): boolean {\n        if (!!this.mediaStream) {\n            if (!this.speechEvent) {\n                const harkOptions = !!this.harkOptions\n                    ? this.harkOptions\n                    : this.session.openvidu.advancedConfiguration.publisherSpeakingEventsOptions || {};\n                harkOptions.interval = typeof harkOptions.interval === 'number' ? harkOptions.interval : 100;\n                harkOptions.threshold = typeof harkOptions.threshold === 'number' ? harkOptions.threshold : -50;\n                this.speechEvent = hark(this.mediaStream, harkOptions);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @hidden\n     */\n    setupReconnectionEventEmitter(resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void): boolean {\n        if (this.reconnectionEventEmitter == undefined) {\n            // There is no ongoing reconnection\n            this.reconnectionEventEmitter = new EventEmitter();\n            return false;\n        } else {\n            // Ongoing reconnection\n            console.warn(\n                `Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) but an ongoing reconnection process is active. Waiting for response...`\n            );\n            this.reconnectionEventEmitter.once('success', () => resolve());\n            this.reconnectionEventEmitter.once('error', (error) => reject(error));\n            return true;\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerSend(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (reconnect) {\n                if (this.setupReconnectionEventEmitter(resolve, reject)) {\n                    // Ongoing reconnection\n                    return;\n                }\n            } else {\n                // MediaStream will already have hark events for reconnected streams\n                this.initHarkEvents(); // Init hark events for the local stream\n            }\n\n            const finalResolve = () => {\n                if (reconnect) {\n                    this.reconnectionEventEmitter?.emitEvent('success');\n                    delete this.reconnectionEventEmitter;\n                }\n                return resolve();\n            };\n\n            const finalReject = (error) => {\n                if (reconnect) {\n                    this.reconnectionEventEmitter?.emitEvent('error', [error]);\n                    delete this.reconnectionEventEmitter;\n                }\n                return reject(error);\n            };\n\n            const successOfferCallback = (sdpOfferParam) => {\n                logger.debug('Sending SDP offer to publish as ' + this.streamId, sdpOfferParam);\n\n                const method = reconnect ? 'reconnectStream' : 'publishVideo';\n                let params;\n                if (reconnect) {\n                    params = {\n                        stream: this.streamId,\n                        sdpString: sdpOfferParam\n                    };\n                } else {\n                    let typeOfVideo;\n                    if (this.isSendVideo()) {\n                        typeOfVideo =\n                            typeof MediaStreamTrack !== 'undefined' &&\n                                this.outboundStreamOpts.publisherProperties.videoSource instanceof MediaStreamTrack\n                                ? TypeOfVideo.CUSTOM\n                                : this.isSendScreen()\n                                    ? TypeOfVideo.SCREEN\n                                    : TypeOfVideo.CAMERA;\n                    }\n                    params = {\n                        doLoopback: this.displayMyRemote() || false,\n                        hasAudio: this.isSendAudio(),\n                        hasVideo: this.isSendVideo(),\n                        audioActive: this.audioActive,\n                        videoActive: this.videoActive,\n                        typeOfVideo,\n                        frameRate: !!this.frameRate ? this.frameRate : -1,\n                        videoDimensions: JSON.stringify(this.videoDimensions),\n                        filter: this.outboundStreamOpts.publisherProperties.filter,\n                        sdpOffer: sdpOfferParam\n                    };\n                }\n\n                this.session.openvidu.sendRequest(method, params, (error, response) => {\n                    if (error) {\n                        if (error.code === 401) {\n                            finalReject(\n                                new OpenViduError(OpenViduErrorName.OPENVIDU_PERMISSION_DENIED, \"You don't have permissions to publish\")\n                            );\n                        } else {\n                            finalReject('Error on publishVideo: ' + JSON.stringify(error));\n                        }\n                    } else {\n                        this.webRtcPeer\n                            .processRemoteAnswer(response.sdpAnswer)\n                            .then(() => {\n                                this.streamId = response.id;\n                                this.creationTime = response.createdAt;\n                                this.isLocalStreamPublished = true;\n                                this.publishedOnce = true;\n                                if (this.displayMyRemote()) {\n                                    this.localMediaStreamWhenSubscribedToRemote = this.mediaStream;\n                                    this.remotePeerSuccessfullyEstablished(reconnect);\n                                }\n                                if (reconnect) {\n                                    this.ee.emitEvent('stream-reconnected-by-publisher', []);\n                                } else {\n                                    this.ee.emitEvent('stream-created-by-publisher', []);\n                                }\n                                this.initWebRtcStats();\n                                logger.info(\n                                    \"'Publisher' (\" +\n                                    this.streamId +\n                                    ') successfully ' +\n                                    (reconnect ? 'reconnected' : 'published') +\n                                    ' to session'\n                                );\n\n                                finalResolve();\n                            })\n                            .catch((error) => {\n                                finalReject(error);\n                            });\n                    }\n                });\n            };\n\n            const config: WebRtcPeerConfiguration = {\n                mediaConstraints: {\n                    audio: this.hasAudio,\n                    video: this.hasVideo\n                },\n                simulcast: this.outboundStreamOpts.publisherProperties.videoSimulcast ?? this.session.openvidu.videoSimulcast,\n                onIceCandidate: this.connection.sendIceCandidate.bind(this.connection),\n                onIceConnectionStateException: this.onIceConnectionStateExceptionHandler.bind(this),\n                iceServers: this.getIceServersConf(),\n                mediaStream: this.mediaStream,\n                mediaServer: this.session.openvidu.mediaServer,\n                typeOfVideo: this.typeOfVideo ? TypeOfVideo[this.typeOfVideo] : undefined\n            };\n\n            if (this.session.openvidu.mediaServer !== 'mediasoup') {\n                // Simulcast is only supported by mediasoup\n                config.simulcast = false;\n            }\n\n            if (reconnect) {\n                this.disposeWebRtcPeer();\n            }\n            if (this.displayMyRemote()) {\n                this.webRtcPeer = new WebRtcPeerSendrecv(config);\n            } else {\n                this.webRtcPeer = new WebRtcPeerSendonly(config);\n            }\n            this.webRtcPeer.addIceConnectionStateChangeListener('publisher of ' + this.connection.connectionId);\n            this.webRtcPeer\n                .createOffer()\n                .then((sdpOffer) => {\n                    this.webRtcPeer\n                        .processLocalOffer(sdpOffer)\n                        .then(() => {\n                            successOfferCallback(sdpOffer.sdp);\n                        })\n                        .catch((error) => {\n                            finalReject(new Error('(publish) SDP process local offer error: ' + JSON.stringify(error)));\n                        });\n                })\n                .catch((error) => {\n                    finalReject(new Error('(publish) SDP create offer error: ' + JSON.stringify(error)));\n                });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    finalResolveForSubscription(reconnect: boolean, resolve: (value: void | PromiseLike<void>) => void) {\n        logger.info(\"'Subscriber' (\" + this.streamId + ') successfully ' + (reconnect ? 'reconnected' : 'subscribed'));\n        this.remotePeerSuccessfullyEstablished(reconnect);\n        this.initWebRtcStats();\n        if (reconnect) {\n            this.reconnectionEventEmitter?.emitEvent('success');\n            delete this.reconnectionEventEmitter;\n        }\n        return resolve();\n    }\n\n    /**\n     * @hidden\n     */\n    finalRejectForSubscription(reconnect: boolean, error: any, reject: (reason?: any) => void) {\n        logger.error(\n            \"Error for 'Subscriber' (\" +\n            this.streamId +\n            ') while trying to ' +\n            (reconnect ? 'reconnect' : 'subscribe') +\n            ': ' +\n            error.toString()\n        );\n        if (reconnect) {\n            this.reconnectionEventEmitter?.emitEvent('error', [error]);\n            delete this.reconnectionEventEmitter;\n        }\n        return reject(error);\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceive(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (reconnect) {\n                if (this.setupReconnectionEventEmitter(resolve, reject)) {\n                    // Ongoing reconnection\n                    return;\n                }\n            }\n\n            if (this.session.openvidu.mediaServer === 'mediasoup') {\n                // Server initiates negotiation\n\n                this.initWebRtcPeerReceiveFromServer(reconnect)\n                    .then(() => this.finalResolveForSubscription(reconnect, resolve))\n                    .catch((error) => this.finalRejectForSubscription(reconnect, error, reject));\n            } else {\n                // Client initiates negotiation\n\n                this.initWebRtcPeerReceiveFromClient(reconnect)\n                    .then(() => this.finalResolveForSubscription(reconnect, resolve))\n                    .catch((error) => this.finalRejectForSubscription(reconnect, error, reject));\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceiveFromClient(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.completeWebRtcPeerReceive(reconnect, false)\n                .then((response) => {\n                    this.webRtcPeer\n                        .processRemoteAnswer(response.sdpAnswer)\n                        .then(() => resolve())\n                        .catch((error) => reject(error));\n                })\n                .catch((error) => reject(error));\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcPeerReceiveFromServer(reconnect: boolean): Promise<void> {\n        return new Promise((resolve, reject) => {\n            // Server initiates negotiation\n            this.session.openvidu.sendRequest('prepareReceiveVideoFrom', { sender: this.streamId, reconnect }, (error, response) => {\n                if (error) {\n                    return reject(new Error('Error on prepareReceiveVideoFrom: ' + JSON.stringify(error)));\n                } else {\n                    this.completeWebRtcPeerReceive(reconnect, false, response.sdpOffer)\n                        .then(() => resolve())\n                        .catch((error) => reject(error));\n                }\n            });\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    completeWebRtcPeerReceive(reconnect: boolean, forciblyReconnect: boolean, sdpOfferByServer?: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            logger.debug(\"'Session.subscribe(Stream)' called\");\n\n            const sendSdpToServer = (sdpString: string) => {\n                logger.debug(`Sending local SDP ${!!sdpOfferByServer ? 'answer' : 'offer'} to subscribe to ${this.streamId}`, sdpString);\n\n                const method = reconnect ? 'reconnectStream' : 'receiveVideoFrom';\n                const params = {};\n                params[reconnect ? 'stream' : 'sender'] = this.streamId;\n                if (!!sdpOfferByServer) {\n                    params[reconnect ? 'sdpString' : 'sdpAnswer'] = sdpString;\n                } else {\n                    params['sdpOffer'] = sdpString;\n                }\n                if (reconnect) {\n                    params['forciblyReconnect'] = forciblyReconnect;\n                }\n\n                this.session.openvidu.sendRequest(method, params, (error, response) => {\n                    if (error) {\n                        return reject(new Error('Error on ' + method + ' : ' + JSON.stringify(error)));\n                    } else {\n                        return resolve(response);\n                    }\n                });\n            };\n\n            const config: WebRtcPeerConfiguration = {\n                mediaConstraints: {\n                    audio: this.hasAudio,\n                    video: this.hasVideo\n                },\n                simulcast: false,\n                onIceCandidate: this.connection.sendIceCandidate.bind(this.connection),\n                onIceConnectionStateException: this.onIceConnectionStateExceptionHandler.bind(this),\n                iceServers: this.getIceServersConf(),\n                mediaServer: this.session.openvidu.mediaServer,\n                typeOfVideo: this.typeOfVideo ? TypeOfVideo[this.typeOfVideo] : undefined\n            };\n\n            if (reconnect) {\n                this.disposeWebRtcPeer();\n            }\n\n            this.webRtcPeer = new WebRtcPeerRecvonly(config);\n            this.webRtcPeer.addIceConnectionStateChangeListener(this.streamId);\n\n            if (!!sdpOfferByServer) {\n                this.webRtcPeer\n                    .processRemoteOffer(sdpOfferByServer)\n                    .then(() => {\n                        this.webRtcPeer\n                            .createAnswer()\n                            .then((sdpAnswer) => {\n                                this.webRtcPeer\n                                    .processLocalAnswer(sdpAnswer)\n                                    .then(() => {\n                                        sendSdpToServer(sdpAnswer.sdp!);\n                                    })\n                                    .catch((error) => {\n                                        return reject(new Error('(subscribe) SDP process local answer error: ' + JSON.stringify(error)));\n                                    });\n                            })\n                            .catch((error) => {\n                                return reject(new Error('(subscribe) SDP create answer error: ' + JSON.stringify(error)));\n                            });\n                    })\n                    .catch((error) => {\n                        return reject(new Error('(subscribe) SDP process remote offer error: ' + JSON.stringify(error)));\n                    });\n            } else {\n                this.webRtcPeer\n                    .createOffer()\n                    .then((sdpOffer) => {\n                        this.webRtcPeer\n                            .processLocalOffer(sdpOffer)\n                            .then(() => {\n                                sendSdpToServer(sdpOffer.sdp!);\n                            })\n                            .catch((error) => {\n                                return reject(new Error('(subscribe) SDP process local offer error: ' + JSON.stringify(error)));\n                            });\n                    })\n                    .catch((error) => {\n                        return reject(new Error('(subscribe) SDP create offer error: ' + JSON.stringify(error)));\n                    });\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    remotePeerSuccessfullyEstablished(reconnect: boolean): void {\n        if (reconnect && this.mediaStream != null) {\n            // Now we can destroy the existing MediaStream\n            this.disposeMediaStream();\n        }\n\n        this.mediaStream = new MediaStream();\n        let receiver: RTCRtpReceiver;\n        for (receiver of this.webRtcPeer.pc.getReceivers()) {\n            if (!!receiver.track) {\n                this.mediaStream.addTrack(receiver.track);\n            }\n        }\n        logger.debug('Peer remote stream', this.mediaStream);\n\n        if (!!this.mediaStream) {\n            if (this.streamManager instanceof Subscriber) {\n                // Apply SubscriberProperties.subscribeToAudio and SubscriberProperties.subscribeToVideo\n                if (!!this.mediaStream.getAudioTracks()[0]) {\n                    const enabled = reconnect ? this.audioActive : !!(this.streamManager as Subscriber).properties.subscribeToAudio;\n                    this.mediaStream.getAudioTracks()[0].enabled = enabled;\n                }\n                if (!!this.mediaStream.getVideoTracks()[0]) {\n                    const enabled = reconnect ? this.videoActive : !!(this.streamManager as Subscriber).properties.subscribeToVideo;\n                    this.mediaStream.getVideoTracks()[0].enabled = enabled;\n                }\n            }\n\n            this.updateMediaStreamInVideos();\n            this.initHarkEvents(); // Init hark events for the remote stream\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    initHarkEvents(): void {\n        if (!!this.mediaStream!.getAudioTracks()[0]) {\n            // Hark events can only be set if audio track is available\n            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', true, this.streamManager)) {\n                this.enableOnceHarkSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStartSpeaking', false, this.streamManager)) {\n                this.enableHarkSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', true, this.streamManager)) {\n                this.enableOnceHarkStoppedSpeakingEvent();\n            }\n            if (this.session.anySpeechEventListenerEnabled('publisherStopSpeaking', false, this.streamManager)) {\n                this.enableHarkStoppedSpeakingEvent();\n            }\n            if (this.harkVolumeChangeEnabledOnce) {\n                this.enableOnceHarkVolumeChangeEvent(true);\n            }\n            if (this.harkVolumeChangeEnabled) {\n                this.enableHarkVolumeChangeEvent(true);\n            }\n        }\n    }\n\n    private onIceConnectionStateExceptionHandler(exceptionName: ExceptionEventName, message: string, data?: any): void {\n        switch (exceptionName) {\n            case ExceptionEventName.ICE_CONNECTION_FAILED:\n                this.onIceConnectionFailed();\n                break;\n            case ExceptionEventName.ICE_CONNECTION_DISCONNECTED:\n                this.onIceConnectionDisconnected();\n                break;\n        }\n        this.session.emitEvent('exception', [new ExceptionEvent(this.session, exceptionName, this, message, data)]);\n    }\n\n    private onIceConnectionFailed() {\n        // Immediately reconnect, as this is a terminal error\n        logger.log(\n            `[ICE_CONNECTION_FAILED] Handling ICE_CONNECTION_FAILED event. Reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n            })`\n        );\n        this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEventName.ICE_CONNECTION_FAILED);\n    }\n\n    private onIceConnectionDisconnected() {\n        // Wait to see if the ICE connection is able to reconnect\n        logger.log(\n            `[ICE_CONNECTION_DISCONNECTED] Handling ICE_CONNECTION_DISCONNECTED event. Waiting for ICE to be restored and reconnect stream ${this.streamId\n            } (${this.isLocal() ? 'Publisher' : 'Subscriber'}) if not possible`\n        );\n        const timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n        this.awaitWebRtcPeerConnectionState(timeout).then((state) => {\n            switch (state) {\n                case 'failed':\n                    // Do nothing, as an ICE_CONNECTION_FAILED event will have already raised\n                    logger.warn(\n                        `[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) is now failed after ICE_CONNECTION_DISCONNECTED`\n                    );\n                    break;\n                case 'connected':\n                case 'completed':\n                    logger.log(\n                        `[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) automatically restored after ICE_CONNECTION_DISCONNECTED. Current ICE connection state: ${state}`\n                    );\n                    break;\n                case 'closed':\n                case 'checking':\n                case 'new':\n                case 'disconnected':\n                    // Rest of states\n                    logger.warn(\n                        `[ICE_CONNECTION_DISCONNECTED] ICE connection of stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) couldn't be restored after ICE_CONNECTION_DISCONNECTED event. Current ICE connection state after ${timeout} ms: ${state}`\n                    );\n                    this.reconnectStreamAndLogResultingIceConnectionState(ExceptionEventName.ICE_CONNECTION_DISCONNECTED);\n                    break;\n            }\n        });\n    }\n\n    private async reconnectStreamAndLogResultingIceConnectionState(event: string) {\n        try {\n            const finalIceStateAfterReconnection = await this.reconnectStreamAndReturnIceConnectionState(event);\n            switch (finalIceStateAfterReconnection) {\n                case 'connected':\n                case 'completed':\n                    logger.log(\n                        `[${event}] Stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) successfully reconnected after ${event}. Current ICE connection state: ${finalIceStateAfterReconnection}`\n                    );\n                    break;\n                default:\n                    logger.error(\n                        `[${event}] Stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                        }) failed to reconnect after ${event}. Current ICE connection state: ${finalIceStateAfterReconnection}`\n                    );\n                    break;\n            }\n        } catch (error) {\n            logger.error(\n                `[${event}] Error reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) after ${event}: ${error}`\n            );\n        }\n    }\n\n    private async reconnectStreamAndReturnIceConnectionState(event: string): Promise<RTCIceConnectionState> {\n        logger.log(`[${event}] Reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'}) after event ${event}`);\n        try {\n            await this.reconnectStream(event);\n            const timeout = this.session.openvidu.advancedConfiguration.iceConnectionDisconnectedExceptionTimeout || 4000;\n            return this.awaitWebRtcPeerConnectionState(timeout);\n        } catch (error) {\n            logger.warn(\n                `[${event}] Error reconnecting stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'}). Reason: ${error}`\n            );\n            return this.awaitWebRtcPeerConnectionState(1);\n        }\n    }\n\n    private async awaitWebRtcPeerConnectionState(timeout: number): Promise<RTCIceConnectionState> {\n        let state = this.getRTCPeerConnection().iceConnectionState;\n        const interval = 150;\n        const intervals = Math.ceil(timeout / interval);\n        for (let i = 0; i < intervals; i++) {\n            state = this.getRTCPeerConnection().iceConnectionState;\n            if (state === 'connected' || state === 'completed') {\n                break;\n            }\n            // Sleep\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n        return state;\n    }\n\n    private async reconnectStream(event: string) {\n        const isWsConnected = await this.isWebsocketConnected(event, 3000);\n        if (isWsConnected) {\n            // There is connection to openvidu-server. The RTCPeerConnection is the only one broken\n            logger.log(\n                `[${event}] Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) and the websocket is opened`\n            );\n            if (this.isLocal()) {\n                return this.initWebRtcPeerSend(true);\n            } else {\n                return this.initWebRtcPeerReceive(true);\n            }\n        } else {\n            // There is no connection to openvidu-server. Nothing can be done. The automatic reconnection\n            // feature should handle a possible reconnection of RTCPeerConnection in case network comes back\n            const errorMsg = `[${event}] Trying to reconnect stream ${this.streamId} (${this.isLocal() ? 'Publisher' : 'Subscriber'\n                }) but the websocket wasn't opened`;\n            logger.error(errorMsg);\n            throw Error(errorMsg);\n        }\n    }\n\n    private isWebsocketConnected(event: string, msResponseTimeout: number): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            const wsReadyState = this.session.openvidu.getWsReadyState();\n            if (wsReadyState === 1) {\n                const responseTimeout = setTimeout(() => {\n                    console.warn(`[${event}] Websocket timeout of ${msResponseTimeout}ms`);\n                    return resolve(false);\n                }, msResponseTimeout);\n                this.session.openvidu.sendRequest('echo', {}, (error, response) => {\n                    clearTimeout(responseTimeout);\n                    if (!!error) {\n                        console.warn(`[${event}] Websocket 'echo' returned error: ${error}`);\n                        return resolve(false);\n                    } else {\n                        return resolve(true);\n                    }\n                });\n            } else {\n                console.warn(`[${event}] Websocket readyState is ${wsReadyState}`);\n                return resolve(false);\n            }\n        });\n    }\n\n    /**\n     * @hidden\n     */\n    initWebRtcStats(): void {\n        this.webRtcStats = new WebRtcStats(this);\n        this.webRtcStats.initWebRtcStats();\n\n        //TODO: send common webrtc stats from client to openvidu-server\n        /*if (this.session.openvidu.webrtcStatsInterval > 0) {\n            setInterval(() => {\n                this.gatherStatsForPeer().then(jsonStats => {\n                    const body = {\n                        sessionId: this.session.sessionId,\n                        participantPrivateId: this.connection.rpcSessionId,\n                        stats: jsonStats\n                    }\n                    var xhr = new XMLHttpRequest();\n                    xhr.open('POST', this.session.openvidu.httpUri + '/elasticsearch/webrtc-stats', true);\n                    xhr.setRequestHeader('Content-Type', 'application/json');\n                    xhr.send(JSON.stringify(body));\n                })\n            }, this.session.openvidu.webrtcStatsInterval * 1000);\n        }*/\n    }\n\n    private stopWebRtcStats(): void {\n        if (!!this.webRtcStats && this.webRtcStats.isEnabled()) {\n            this.webRtcStats.stopWebRtcStats();\n        }\n    }\n\n    private getIceServersConf(): RTCIceServer[] | undefined {\n        let returnValue;\n        if (!!this.session.openvidu.advancedConfiguration.iceServers) {\n            returnValue =\n                this.session.openvidu.advancedConfiguration.iceServers === 'freeice'\n                    ? undefined\n                    : this.session.openvidu.advancedConfiguration.iceServers;\n        } else if (this.session.openvidu.iceServers) {\n            returnValue = this.session.openvidu.iceServers;\n        } else {\n            returnValue = undefined;\n        }\n        return returnValue;\n    }\n\n    private gatherStatsForPeer(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.isLocal()) {\n                // Publisher stream stats\n\n                this.getRTCPeerConnection()\n                    .getSenders()\n                    .forEach((sender) =>\n                        sender.getStats().then((response) => {\n                            response.forEach((report) => {\n                                if (this.isReportWanted(report)) {\n                                    const finalReport = {};\n\n                                    finalReport['type'] = report.type;\n                                    finalReport['timestamp'] = report.timestamp;\n                                    finalReport['id'] = report.id;\n\n                                    // Common to Chrome, Firefox and Safari\n                                    if (report.type === 'outbound-rtp') {\n                                        finalReport['ssrc'] = report.ssrc;\n                                        finalReport['firCount'] = report.firCount;\n                                        finalReport['pliCount'] = report.pliCount;\n                                        finalReport['nackCount'] = report.nackCount;\n                                        finalReport['qpSum'] = report.qpSum;\n\n                                        // Set media type\n                                        if (!!report.kind) {\n                                            finalReport['mediaType'] = report.kind;\n                                        } else if (!!report.mediaType) {\n                                            finalReport['mediaType'] = report.mediaType;\n                                        } else {\n                                            // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                                            finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                                        }\n\n                                        if (finalReport['mediaType'] === 'video') {\n                                            finalReport['framesEncoded'] = report.framesEncoded;\n                                        }\n\n                                        finalReport['packetsSent'] = report.packetsSent;\n                                        finalReport['bytesSent'] = report.bytesSent;\n                                    }\n\n                                    // Only for Chrome and Safari\n                                    if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                                        // This is the final selected candidate pair\n                                        finalReport['availableOutgoingBitrate'] = report.availableOutgoingBitrate;\n                                        finalReport['rtt'] = report.currentRoundTripTime;\n                                        finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                                    }\n\n                                    // Only for Firefox >= 66.0\n                                    if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {\n                                    }\n\n                                    logger.log(finalReport);\n                                }\n                            });\n                        })\n                    );\n            } else {\n                // Subscriber stream stats\n\n                this.getRTCPeerConnection()\n                    .getReceivers()\n                    .forEach((receiver) =>\n                        receiver.getStats().then((response) => {\n                            response.forEach((report) => {\n                                if (this.isReportWanted(report)) {\n                                    const finalReport = {};\n\n                                    finalReport['type'] = report.type;\n                                    finalReport['timestamp'] = report.timestamp;\n                                    finalReport['id'] = report.id;\n\n                                    // Common to Chrome, Firefox and Safari\n                                    if (report.type === 'inbound-rtp') {\n                                        finalReport['ssrc'] = report.ssrc;\n                                        finalReport['firCount'] = report.firCount;\n                                        finalReport['pliCount'] = report.pliCount;\n                                        finalReport['nackCount'] = report.nackCount;\n                                        finalReport['qpSum'] = report.qpSum;\n\n                                        // Set media type\n                                        if (!!report.kind) {\n                                            finalReport['mediaType'] = report.kind;\n                                        } else if (!!report.mediaType) {\n                                            finalReport['mediaType'] = report.mediaType;\n                                        } else {\n                                            // Safari does not have 'mediaType' defined for inbound-rtp. Must be inferred from 'id' field\n                                            finalReport['mediaType'] = report.id.indexOf('VideoStream') !== -1 ? 'video' : 'audio';\n                                        }\n\n                                        if (finalReport['mediaType'] === 'video') {\n                                            finalReport['framesDecoded'] = report.framesDecoded;\n                                        }\n\n                                        finalReport['packetsReceived'] = report.packetsReceived;\n                                        finalReport['packetsLost'] = report.packetsLost;\n                                        finalReport['jitter'] = report.jitter;\n                                        finalReport['bytesReceived'] = report.bytesReceived;\n                                    }\n\n                                    // Only for Chrome and Safari\n                                    if (report.type === 'candidate-pair' && report.totalRoundTripTime !== undefined) {\n                                        // This is the final selected candidate pair\n                                        finalReport['availableIncomingBitrate'] = report.availableIncomingBitrate;\n                                        finalReport['rtt'] = report.currentRoundTripTime;\n                                        finalReport['averageRtt'] = report.totalRoundTripTime / report.responsesReceived;\n                                    }\n\n                                    // Only for Firefox >= 66.0\n                                    if (report.type === 'remote-inbound-rtp' || report.type === 'remote-outbound-rtp') {\n                                    }\n                                    logger.log(finalReport);\n                                }\n                            });\n                        })\n                    );\n            }\n        });\n    }\n\n    private isReportWanted(report: any): boolean {\n        return (\n            (report.type === 'inbound-rtp' && !this.isLocal()) ||\n            (report.type === 'outbound-rtp' && this.isLocal()) ||\n            (report.type === 'candidate-pair' && report.nominated && report.bytesSent > 0)\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}