{"ast":null,"code":"\"use strict\";\n\n/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalRecorder = void 0;\nvar LocalRecorderState_1 = require(\"../OpenViduInternal/Enums/LocalRecorderState\");\nvar OpenViduLogger_1 = require(\"../OpenViduInternal/Logger/OpenViduLogger\");\nvar Platform_1 = require(\"../OpenViduInternal/Utils/Platform\");\nvar Mime = require(\"mime/lite\");\n/**\n * @hidden\n */\nvar logger = OpenViduLogger_1.OpenViduLogger.getInstance();\n/**\n * @hidden\n */\nvar platform;\n/**\n * Easy recording of {@link Stream} objects straightaway from the browser. Initialized with {@link OpenVidu.initLocalRecorder} method\n */\nvar LocalRecorder = /** @class */function () {\n  /**\n   * @hidden\n   */\n  function LocalRecorder(stream) {\n    this.stream = stream;\n    this.chunks = [];\n    platform = Platform_1.PlatformUtils.getInstance();\n    this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n    this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n    this.state = LocalRecorderState_1.LocalRecorderState.READY;\n  }\n  /**\n   * Starts the recording of the Stream. {@link state} property must be `READY`. After method succeeds is set to `RECORDING`\n   *\n   * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n   * For example:\n   *\n   * ```javascript\n   * var OV = new OpenVidu();\n   * var publisher = await OV.initPublisherAsync();\n   * var localRecorder = OV.initLocalRecorder(publisher.stream);\n   * var options = {\n   *      mimeType: 'video/webm;codecs=vp8',\n   *      audioBitsPerSecond:128000,\n   *      videoBitsPerSecond:2500000\n   * };\n   * localRecorder.record(options);\n   * ```\n   *\n   * If not specified, the default options preferred by the platform will be used.\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.record = function (options) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (typeof options === 'string' || options instanceof String) {\n          return reject(\"When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \\\"\".concat(options, \"\\\" }\"));\n        }\n        if (typeof MediaRecorder === 'undefined') {\n          logger.error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n          throw Error('MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder');\n        }\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.READY) {\n          throw Error(\"'LocalRecord.record()' needs 'LocalRecord.state' to be 'READY' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.clean()' or init a new LocalRecorder before\");\n        }\n        logger.log(\"Starting local recording of stream '\" + _this.stream.streamId + \"' of connection '\" + _this.connectionId + \"'\");\n        if (!options) {\n          options = {\n            mimeType: 'video/webm'\n          };\n        } else if (!options.mimeType) {\n          options.mimeType = 'video/webm';\n        }\n        _this.mediaRecorder = new MediaRecorder(_this.stream.getMediaStream(), options);\n        _this.mediaRecorder.start();\n      } catch (err) {\n        return reject(err);\n      }\n      _this.mediaRecorder.ondataavailable = function (e) {\n        if (e.data.size > 0) {\n          _this.chunks.push(e.data);\n        }\n      };\n      _this.mediaRecorder.onerror = function (e) {\n        logger.error('MediaRecorder error: ', e);\n      };\n      _this.mediaRecorder.onstart = function () {\n        logger.log('MediaRecorder started (state=' + _this.mediaRecorder.state + ')');\n      };\n      _this.mediaRecorder.onstop = function () {\n        _this.onStopDefault();\n      };\n      _this.mediaRecorder.onpause = function () {\n        logger.log('MediaRecorder paused (state=' + _this.mediaRecorder.state + ')');\n      };\n      _this.mediaRecorder.onresume = function () {\n        logger.log('MediaRecorder resumed (state=' + _this.mediaRecorder.state + ')');\n      };\n      _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n      return resolve();\n    });\n  };\n  /**\n   * Ends the recording of the Stream. {@link state} property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.stop = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state === LocalRecorderState_1.LocalRecorderState.READY || _this.state === LocalRecorderState_1.LocalRecorderState.FINISHED) {\n          throw Error(\"'LocalRecord.stop()' needs 'LocalRecord.state' to be 'RECORDING' or 'PAUSED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.start()' before\");\n        }\n        _this.mediaRecorder.onstop = function () {\n          _this.onStopDefault();\n          return resolve();\n        };\n        _this.mediaRecorder.stop();\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\n   * Pauses the recording of the Stream. {@link state} property must be `RECORDING`. After method succeeds is set to `PAUSED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.pause = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.RECORDING) {\n          return reject(Error(\"'LocalRecord.pause()' needs 'LocalRecord.state' to be 'RECORDING' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.start()' or 'LocalRecorder.resume()' before\"));\n        }\n        _this.mediaRecorder.pause();\n        _this.state = LocalRecorderState_1.LocalRecorderState.PAUSED;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Resumes the recording of the Stream. {@link state} property must be `PAUSED`. After method succeeds is set to `RECORDING`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n   */\n  LocalRecorder.prototype.resume = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.PAUSED) {\n          throw Error(\"'LocalRecord.resume()' needs 'LocalRecord.state' to be 'PAUSED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.pause()' before\");\n        }\n        _this.mediaRecorder.resume();\n        _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n        return resolve();\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  };\n  /**\n   * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. {@link state} property must be `FINISHED`\n   */\n  LocalRecorder.prototype.preview = function (parentElement) {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error(\"'LocalRecord.preview()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + this.state + \"'). Call 'LocalRecorder.stop()' before\");\n    }\n    this.videoPreview = document.createElement('video');\n    this.videoPreview.id = this.id;\n    this.videoPreview.autoplay = true;\n    if (platform.isSafariBrowser()) {\n      this.videoPreview.playsInline = true;\n    }\n    if (typeof parentElement === 'string') {\n      var parentElementDom = document.getElementById(parentElement);\n      if (parentElementDom) {\n        this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n      }\n    } else {\n      this.videoPreview = parentElement.appendChild(this.videoPreview);\n    }\n    this.videoPreview.src = this.videoPreviewSrc;\n    return this.videoPreview;\n  };\n  /**\n   * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets {@link state} to `READY` so the recording can start again\n   */\n  LocalRecorder.prototype.clean = function () {\n    var _this = this;\n    var f = function f() {\n      delete _this.blob;\n      _this.chunks = [];\n      _this.state = LocalRecorderState_1.LocalRecorderState.READY;\n    };\n    if (this.state === LocalRecorderState_1.LocalRecorderState.RECORDING || this.state === LocalRecorderState_1.LocalRecorderState.PAUSED) {\n      this.stop().then(function () {\n        return f();\n      }).catch(function () {\n        return f();\n      });\n    } else {\n      f();\n    }\n  };\n  /**\n   * Downloads the recorded video through the browser. {@link state} property must be `FINISHED`\n   */\n  LocalRecorder.prototype.download = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error(\"'LocalRecord.download()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + this.state + \"'). Call 'LocalRecorder.stop()' before\");\n    } else {\n      var a = document.createElement('a');\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      var url = globalThis.URL.createObjectURL(this.blob);\n      a.href = url;\n      a.download = this.id + '.' + Mime.getExtension(this.blob.type);\n      a.click();\n      globalThis.URL.revokeObjectURL(url);\n      document.body.removeChild(a);\n    }\n  };\n  /**\n   * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. {@link state} property must be `FINISHED`\n   */\n  LocalRecorder.prototype.getBlob = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error(\"Call 'LocalRecord.stop()' before getting Blob file\");\n    } else {\n      return this.blob;\n    }\n  };\n  /**\n   * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n   */\n  LocalRecorder.prototype.uploadAsBinary = function (endpoint, headers) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error(\"'LocalRecord.uploadAsBinary()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.stop()' before\"));\n      } else {\n        var http_1 = new XMLHttpRequest();\n        http_1.open('POST', endpoint, true);\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_1.setRequestHeader(key, headers[key]);\n          }\n        }\n        http_1.onreadystatechange = function () {\n          if (http_1.readyState === 4) {\n            if (http_1.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_1.responseText);\n            } else {\n              return reject(http_1.status);\n            }\n          }\n        };\n        http_1.send(_this.blob);\n      }\n    });\n  };\n  /**\n   * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n   */\n  LocalRecorder.prototype.uploadAsMultipartfile = function (endpoint, headers) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        return reject(Error(\"'LocalRecord.uploadAsMultipartfile()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" + _this.state + \"'). Call 'LocalRecorder.stop()' before\"));\n      } else {\n        var http_2 = new XMLHttpRequest();\n        http_2.open('POST', endpoint, true);\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_2.setRequestHeader(key, headers[key]);\n          }\n        }\n        var sendable = new FormData();\n        sendable.append('file', _this.blob, _this.id + '.' + Mime.getExtension(_this.blob.type));\n        http_2.onreadystatechange = function () {\n          if (http_2.readyState === 4) {\n            if (http_2.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              return resolve(http_2.responseText);\n            } else {\n              return reject(http_2.status);\n            }\n          }\n        };\n        http_2.send(sendable);\n      }\n    });\n  };\n  /* Private methods */\n  LocalRecorder.prototype.onStopDefault = function () {\n    logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n    this.blob = new Blob(this.chunks, {\n      type: this.mediaRecorder.mimeType\n    });\n    this.chunks = [];\n    this.videoPreviewSrc = globalThis.URL.createObjectURL(this.blob);\n    this.state = LocalRecorderState_1.LocalRecorderState.FINISHED;\n  };\n  return LocalRecorder;\n}();\nexports.LocalRecorder = LocalRecorder;","map":{"version":3,"mappings":"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","names":["logger","OpenViduLogger_1","getInstance","platform","stream","Platform_1","connectionId","connection","id","streamId","state","LocalRecorderState_1","READY","LocalRecorder","options","Promise","resolve","reject","String","MediaRecorder","error","Error","_this","log","mimeType","mediaRecorder","getMediaStream","start","err","ondataavailable","e","data","size","chunks","push","onerror","onstart","onstop","onStopDefault","onpause","onresume","RECORDING","FINISHED","stop","pause","PAUSED","resume","parentElement","videoPreview","document","createElement","autoplay","isSafariBrowser","playsInline","parentElementDom","getElementById","appendChild","src","videoPreviewSrc","f","blob","then","catch","a","style","display","body","url","globalThis","URL","createObjectURL","href","download","Mime","getExtension","type","click","revokeObjectURL","removeChild","endpoint","headers","http_1","XMLHttpRequest","open","_a","keys","_i","key","setRequestHeader","onreadystatechange","readyState","status","toString","charAt","responseText","send","http_2","sendable","FormData","append","Blob","exports"],"sources":["C:\\Users\\user\\Desktop\\openvidu-client\\node_modules\\openvidu-browser\\src\\OpenVidu\\LocalRecorder.ts"],"sourcesContent":["/*\n * (C) Copyright 2017-2022 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Stream } from './Stream';\nimport { LocalRecorderState } from '../OpenViduInternal/Enums/LocalRecorderState';\nimport { OpenViduLogger } from '../OpenViduInternal/Logger/OpenViduLogger';\nimport { PlatformUtils } from '../OpenViduInternal/Utils/Platform';\nimport Mime = require('mime/lite');\n\n/**\n * @hidden\n */\nconst logger: OpenViduLogger = OpenViduLogger.getInstance();\n\n/**\n * @hidden\n */\nlet platform: PlatformUtils;\n\n/**\n * Easy recording of {@link Stream} objects straightaway from the browser. Initialized with {@link OpenVidu.initLocalRecorder} method\n */\nexport class LocalRecorder {\n    state: LocalRecorderState;\n\n    private connectionId: string;\n    private mediaRecorder: MediaRecorder;\n    private chunks: any[] = [];\n    private blob?: Blob;\n    private id: string;\n    private videoPreviewSrc: string;\n    private videoPreview: HTMLVideoElement;\n\n    /**\n     * @hidden\n     */\n    constructor(private stream: Stream) {\n        platform = PlatformUtils.getInstance();\n        this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n        this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n        this.state = LocalRecorderState.READY;\n    }\n\n    /**\n     * Starts the recording of the Stream. {@link state} property must be `READY`. After method succeeds is set to `RECORDING`\n     *\n     * @param options The [MediaRecorder.options](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#parameters) to be used to record this Stream.\n     * For example:\n     *\n     * ```javascript\n     * var OV = new OpenVidu();\n     * var publisher = await OV.initPublisherAsync();\n     * var localRecorder = OV.initLocalRecorder(publisher.stream);\n     * var options = {\n     *      mimeType: 'video/webm;codecs=vp8',\n     *      audioBitsPerSecond:128000,\n     *      videoBitsPerSecond:2500000\n     * };\n     * localRecorder.record(options);\n     * ```\n     *\n     * If not specified, the default options preferred by the platform will be used.\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n     */\n    record(options?: any): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (typeof options === 'string' || options instanceof String) {\n                    return reject(\n                        `When calling LocalRecorder.record(options) parameter 'options' cannot be a string. Must be an object like { mimeType: \"${options}\" }`\n                    );\n                }\n                if (typeof MediaRecorder === 'undefined') {\n                    logger.error(\n                        'MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder'\n                    );\n                    throw Error(\n                        'MediaRecorder not supported on your device. See compatibility in https://caniuse.com/#search=MediaRecorder'\n                    );\n                }\n                if (this.state !== LocalRecorderState.READY) {\n                    throw Error(\n                        \"'LocalRecord.record()' needs 'LocalRecord.state' to be 'READY' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.clean()' or init a new LocalRecorder before\"\n                    );\n                }\n                logger.log(\"Starting local recording of stream '\" + this.stream.streamId + \"' of connection '\" + this.connectionId + \"'\");\n\n                if (!options) {\n                    options = { mimeType: 'video/webm' };\n                } else if (!options.mimeType) {\n                    options.mimeType = 'video/webm';\n                }\n\n                this.mediaRecorder = new MediaRecorder(this.stream.getMediaStream(), options);\n                this.mediaRecorder.start();\n            } catch (err) {\n                return reject(err);\n            }\n\n            this.mediaRecorder.ondataavailable = (e) => {\n                if (e.data.size > 0) {\n                    this.chunks.push(e.data);\n                }\n            };\n\n            this.mediaRecorder.onerror = (e) => {\n                logger.error('MediaRecorder error: ', e);\n            };\n\n            this.mediaRecorder.onstart = () => {\n                logger.log('MediaRecorder started (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.mediaRecorder.onstop = () => {\n                this.onStopDefault();\n            };\n\n            this.mediaRecorder.onpause = () => {\n                logger.log('MediaRecorder paused (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.mediaRecorder.onresume = () => {\n                logger.log('MediaRecorder resumed (state=' + this.mediaRecorder.state + ')');\n            };\n\n            this.state = LocalRecorderState.RECORDING;\n            return resolve();\n        });\n    }\n\n    /**\n     * Ends the recording of the Stream. {@link state} property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n     */\n    stop(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state === LocalRecorderState.READY || this.state === LocalRecorderState.FINISHED) {\n                    throw Error(\n                        \"'LocalRecord.stop()' needs 'LocalRecord.state' to be 'RECORDING' or 'PAUSED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.start()' before\"\n                    );\n                }\n                this.mediaRecorder.onstop = () => {\n                    this.onStopDefault();\n                    return resolve();\n                };\n                this.mediaRecorder.stop();\n            } catch (e) {\n                return reject(e);\n            }\n        });\n    }\n\n    /**\n     * Pauses the recording of the Stream. {@link state} property must be `RECORDING`. After method succeeds is set to `PAUSED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n     */\n    pause(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state !== LocalRecorderState.RECORDING) {\n                    return reject(\n                        Error(\n                            \"'LocalRecord.pause()' needs 'LocalRecord.state' to be 'RECORDING' (current value: '\" +\n                                this.state +\n                                \"'). Call 'LocalRecorder.start()' or 'LocalRecorder.resume()' before\"\n                        )\n                    );\n                }\n                this.mediaRecorder.pause();\n                this.state = LocalRecorderState.PAUSED;\n                return resolve();\n            } catch (error) {\n                return reject(error);\n            }\n        });\n    }\n\n    /**\n     * Resumes the recording of the Stream. {@link state} property must be `PAUSED`. After method succeeds is set to `RECORDING`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n     */\n    resume(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this.state !== LocalRecorderState.PAUSED) {\n                    throw Error(\n                        \"'LocalRecord.resume()' needs 'LocalRecord.state' to be 'PAUSED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.pause()' before\"\n                    );\n                }\n                this.mediaRecorder.resume();\n                this.state = LocalRecorderState.RECORDING;\n                return resolve();\n            } catch (error) {\n                return reject(error);\n            }\n        });\n    }\n\n    /**\n     * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. {@link state} property must be `FINISHED`\n     */\n    preview(parentElement): HTMLVideoElement {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw Error(\n                \"'LocalRecord.preview()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                    this.state +\n                    \"'). Call 'LocalRecorder.stop()' before\"\n            );\n        }\n\n        this.videoPreview = document.createElement('video');\n\n        this.videoPreview.id = this.id;\n        this.videoPreview.autoplay = true;\n\n        if (platform.isSafariBrowser()) {\n            this.videoPreview.playsInline = true;\n        }\n\n        if (typeof parentElement === 'string') {\n            const parentElementDom = document.getElementById(parentElement);\n            if (parentElementDom) {\n                this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n            }\n        } else {\n            this.videoPreview = parentElement.appendChild(this.videoPreview);\n        }\n\n        this.videoPreview.src = this.videoPreviewSrc;\n\n        return this.videoPreview;\n    }\n\n    /**\n     * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets {@link state} to `READY` so the recording can start again\n     */\n    clean(): void {\n        const f = () => {\n            delete this.blob;\n            this.chunks = [];\n            this.state = LocalRecorderState.READY;\n        };\n        if (this.state === LocalRecorderState.RECORDING || this.state === LocalRecorderState.PAUSED) {\n            this.stop()\n                .then(() => f())\n                .catch(() => f());\n        } else {\n            f();\n        }\n    }\n\n    /**\n     * Downloads the recorded video through the browser. {@link state} property must be `FINISHED`\n     */\n    download(): void {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw Error(\n                \"'LocalRecord.download()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                    this.state +\n                    \"'). Call 'LocalRecorder.stop()' before\"\n            );\n        } else {\n            const a: HTMLAnchorElement = document.createElement('a');\n            a.style.display = 'none';\n            document.body.appendChild(a);\n\n            const url = globalThis.URL.createObjectURL(<any>this.blob);\n            a.href = url;\n            a.download = this.id + '.' + Mime.getExtension(this.blob!.type);\n            a.click();\n            globalThis.URL.revokeObjectURL(url);\n\n            document.body.removeChild(a);\n        }\n    }\n\n    /**\n     * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. {@link state} property must be `FINISHED`\n     */\n    getBlob(): Blob {\n        if (this.state !== LocalRecorderState.FINISHED) {\n            throw Error(\"Call 'LocalRecord.stop()' before getting Blob file\");\n        } else {\n            return this.blob!;\n        }\n    }\n\n    /**\n     * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n     */\n    uploadAsBinary(endpoint: string, headers?: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.state !== LocalRecorderState.FINISHED) {\n                return reject(\n                    Error(\n                        \"'LocalRecord.uploadAsBinary()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.stop()' before\"\n                    )\n                );\n            } else {\n                const http = new XMLHttpRequest();\n                http.open('POST', endpoint, true);\n\n                if (typeof headers === 'object') {\n                    for (const key of Object.keys(headers)) {\n                        http.setRequestHeader(key, headers[key]);\n                    }\n                }\n\n                http.onreadystatechange = () => {\n                    if (http.readyState === 4) {\n                        if (http.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            return resolve(http.responseText);\n                        } else {\n                            return reject(http.status);\n                        }\n                    }\n                };\n                http.send(this.blob);\n            }\n        });\n    }\n\n    /**\n     * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. {@link state} property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n     */\n    uploadAsMultipartfile(endpoint: string, headers?: any): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.state !== LocalRecorderState.FINISHED) {\n                return reject(\n                    Error(\n                        \"'LocalRecord.uploadAsMultipartfile()' needs 'LocalRecord.state' to be 'FINISHED' (current value: '\" +\n                            this.state +\n                            \"'). Call 'LocalRecorder.stop()' before\"\n                    )\n                );\n            } else {\n                const http = new XMLHttpRequest();\n                http.open('POST', endpoint, true);\n\n                if (typeof headers === 'object') {\n                    for (const key of Object.keys(headers)) {\n                        http.setRequestHeader(key, headers[key]);\n                    }\n                }\n\n                const sendable = new FormData();\n                sendable.append('file', this.blob!, this.id + '.' + Mime.getExtension(this.blob!.type));\n\n                http.onreadystatechange = () => {\n                    if (http.readyState === 4) {\n                        if (http.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            return resolve(http.responseText);\n                        } else {\n                            return reject(http.status);\n                        }\n                    }\n                };\n\n                http.send(sendable);\n            }\n        });\n    }\n\n    /* Private methods */\n\n    private onStopDefault(): void {\n        logger.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n\n        this.blob = new Blob(this.chunks, { type: this.mediaRecorder.mimeType });\n        this.chunks = [];\n\n        this.videoPreviewSrc = globalThis.URL.createObjectURL(this.blob);\n\n        this.state = LocalRecorderState.FINISHED;\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}